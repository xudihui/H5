/********************************************************************/
/*                                                                  */
/*  Copyright (c) 2014 Genesis Mobile                               */
/*                                                                  */
/*  This obfuscated code was created by Jasob 4.1 Trial Version.    */
/*  The code may be used for evaluation purposes only.              */
/*  To obtain full rights to the obfuscated code you have to        */
/*  purchase the license key (http://www.jasob.com/Purchase.html).  */
/*                                                                  */
/********************************************************************/

var base64EncodeChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var base64DecodeChars = new Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);

function cV(str) {
	var out, i, len;
	var c1, c2, c3;
	len = str.length;
	i = 0;
	out = "";
	while (i < len) {
		c1 = str.charCodeAt(i++) & 0xff;
		if (i == len) {
			out += base64EncodeChars.charAt(c1 >> 2);
			out += base64EncodeChars.charAt((c1 & 0x3) << 4);
			out += "==";
			break;
		}
		c2 = str.charCodeAt(i++);
		if (i == len) {
			out += base64EncodeChars.charAt(c1 >> 2);
			out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
			out += base64EncodeChars.charAt((c2 & 0xF) << 2);
			out += "=";
			break;
		}
		c3 = str.charCodeAt(i++);
		out += base64EncodeChars.charAt(c1 >> 2);
		out += base64EncodeChars.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
		out += base64EncodeChars.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));
		out += base64EncodeChars.charAt(c3 & 0x3F);
	}
	return out;
};

function J(str) {
	var c1, c2, c3, c4;
	var i, len, out;
	len = str.length;
	i = 0;
	out = "";
	while (i < len) {
		do {
			c1 = base64DecodeChars[str.charCodeAt(i++) & 0xff];
		} while (i < len && c1 == -1);
		if (c1 == -1) break;
		do {
			c2 = base64DecodeChars[str.charCodeAt(i++) & 0xff];
		} while (i < len && c2 == -1);
		if (c2 == -1) break;
		out += String.fromCharCode((c1 << 2) | ((c2 & 0x30) >> 4));
		do {
			c3 = str.charCodeAt(i++) & 0xff;
			if (c3 == 61) return out;
			c3 = base64DecodeChars[c3];
		} while (i < len && c3 == -1);
		if (c3 == -1) break;
		out += String.fromCharCode(((c2 & 0XF) << 4) | ((c3 & 0x3C) >> 2));
		do {
			c4 = str.charCodeAt(i++) & 0xff;
			if (c4 == 61) return out;
			c4 = base64DecodeChars[c4];
		} while (i < len && c4 == -1);
		if (c4 == -1) break;
		out += String.fromCharCode(((c3 & 0x03) << 6) | c4);
	}
	return out;
};
var u = navigator.userAgent;
var aj = u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;
var ag = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
var aI = function() {
		var r = true;
		if (/MediaPad/i.test(u)) return false;
		r = (/Mobile/i.test(u) && !/ipad/i.test(u));
		return r;
	};

function keyBoard(options) {
	this.settings = {
		"id": "",
		"chaosMode": 0,
		"pressStatus": 1,
		"kbType": 0,
		"pg": {},
		"odd": 1,
		"reset": 0
	};
	this.activeobj = undefined;
	if (options != undefined) {
		this.settings = options;
	}
	this.caps = false;
	this.shift = false;
	this.dt = false;
	this.init = false;
	var obj = this;
	this.handler = function() {
		var curid = "#" + obj.settings.id;
		$(curid).hide();
		document.querySelector(curid).removeEventListener("webkitAnimationEnd", obj.handler, false);
	};
	this.orientation = function() {
		var b = u.indexOf('SM-T800') > -1;
		if (!b) {
			return window.orientation;
		}
		var ret = 0;
		switch (window.orientation) {
		case 0:
			ret = 90;
			break;
		case 90:
			ret = 180;
			break;
		case 180:
			ret = -90;
			break;
		case -90:
			ret = 180;
			break;
		}
		return ret;
	};
	this.proportion = function() {
		var r = 0;
		if ((this.orientation() == 90) || (this.orientation() == -90)) {
			if (ag) {
				if (aI()) r = 0.65;
				else r = 0.40;
			} else if (aj) {
				if (aI()) r = 0.65;
				else r = 0.40;
			} else {
				r = 0.65;
			}
		} else {
			if (ag) {
				if (aI()) r = 0.43;
				else r = 0.35;
			} else if (aj) {
				if (aI()) r = 0.43;
				else r = 0.35;
			} else {
				r = 0.43;
			}
		}
		return r;
	};
	this.endshow = function() {
		var curid = "#" + obj.settings.id;
		if ((obj.orientation() == 90) || (obj.orientation() == -90)) {
			if (obj.caps) {
				$("#kb_c_CAP").css("background-image", "url(svg/shift_DS_H.svg)");
			} else if (obj.shift) {
				$("#kb_c_CAP").css("background-image", "url(svg/shift_D_H.svg)");
			} else {
				$("#kb_c_CAP").css("background-image", "url(svg/shift_H.svg)");
			}
			$("#kb_c_D").css("background-image", "url(svg/DEL_H.svg)");
			$("#kb_n_D").css("background-image", "url(svg/DEL_H.svg)");
			$("#kb_s_D").css("background-image", "url(svg/DEL_H.svg)");
			$("#kb_p_D").css("background-image", "url(svg/shuzi_delete_1.svg)");
			$("#kb_c_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_n_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_s_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_p_CLOSE").css("background-image", "url(svg/shuzi_shouqi_1.svg)");
		} else {
			if (obj.caps) {
				$("#kb_c_CAP").css("background-image", "url(svg/shift_DS.svg)");
			} else if (obj.shift) {
				$("#kb_c_CAP").css("background-image", "url(svg/shift_D.svg)");
			} else {
				$("#kb_c_CAP").css("background-image", "url(svg/shift.svg)");
			}
			$("#kb_c_D").css("background-image", "url(svg/DEL.svg)");
			$("#kb_n_D").css("background-image", "url(svg/DEL.svg)");
			$("#kb_s_D").css("background-image", "url(svg/DEL.svg)");
			$("#kb_p_D").css("background-image", "url(svg/shuzi_delete_1.svg)");
			$("#kb_c_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_n_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_s_CLOSE").css("background-image", "url(svg/shouqi.svg)");
			$("#kb_p_CLOSE").css("background-image", "url(svg/shuzi_shouqi_1.svg)");
		}
		var regr = new RegExp("row\\d");
		var regk = new RegExp("_keyboard");
		$(curid).contents("div").filter(function() {
			if (regk.test(this.id)) {
				$("#" + this.id).contents("div").filter(function() {
					if (regr.test(this.className)) {
						$(this).contents("div").filter(function() {
							var h = $("#" + this.id).height();
							$("#" + this.id).css("line-height", h + "px");
						});
					}
				});
			}
		});
		document.querySelector(curid).removeEventListener("webkitAnimationEnd", obj.endshow, false);
	}
};
keyBoard.prototype.generate = function() {
	this.settings.id = "testkbid";
	var bY = '<div id=' + this.settings.id,
		ct = 'IGNsYXNzPSJwd2RrZXlib2FyZCIgc3R5bGU9ImRpc3BsYXk6IG5vbmU7IGJvdHRvbTogMHB4OyBtYXJnaW4tbGVmdDogMHB4OyIgPjxkaXYgaWQ9ImNoYXJfa2V5Ym9hcmQiIHN0eWxlPSJ3aWR0aDoxMDAlOyBoZWlnaHQ6MTAwJSA7IGRpc3BsYXk6bm9uZTsiPjxkaXYgY2xhc3M9InJvdzEiPg==',
		dq = "PGRpdiBpZD0ia2JfY18wIiBjbGFzcz0icm93MXB3ZCByb3dsZWZ0IiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPnE8L2Rpdj4=",
		aQ = "PGRpdiBpZD0ia2JfY18xIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij53PC9kaXY+",
		bG = "PGRpdiBpZD0ia2JfY18yIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5lPC9kaXY+",
		ap = "PGRpdiBpZD0ia2JfY18zIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5yPC9kaXY+",
		aP = "PGRpdiBpZD0ia2JfY180IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij50PC9kaXY+",
		cg = "PGRpdiBpZD0ia2JfY181IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij55PC9kaXY+",
		df = "PGRpdiBpZD0ia2JfY182IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij51PC9kaXY+",
		dc = "PGRpdiBpZD0ia2JfY183IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5pPC9kaXY+",
		cz = "PGRpdiBpZD0ia2JfY184IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5vPC9kaXY+",
		bX = "PGRpdiBpZD0ia2JfY185IiBjbGFzcz0icm93MXB3ZCByb3dyaWdodCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5wPC9kaXY+",
		cF = "PC9kaXY+PGRpdiBjbGFzcz0icm93MiI+PGRpdiBpZD0ia2JfY18xMCIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+YTwvZGl2Pg==",
		cW = "PGRpdiBpZD0ia2JfY18xMSIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+czwvZGl2Pg==",
		ca = "PGRpdiBpZD0ia2JfY18xMiIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+ZDwvZGl2Pg==",
		bD = "PGRpdiBpZD0ia2JfY18xMyIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+ZjwvZGl2Pg==",
		be = "PGRpdiBpZD0ia2JfY18xNCIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+ZzwvZGl2Pg==",
		bx = "PGRpdiBpZD0ia2JfY18xNSIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+aDwvZGl2Pg==",
		aG = "PGRpdiBpZD0ia2JfY18xNiIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+ajwvZGl2Pg==",
		ak = "PGRpdiBpZD0ia2JfY18xNyIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+azwvZGl2Pg==",
		ab = "PGRpdiBpZD0ia2JfY18xOCIgY2xhc3M9InJvdzJwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+bDwvZGl2Pg==",
		aC = "PC9kaXY+PGRpdiBjbGFzcz0icm93MyI+PGRpdiBpZD0ia2JfY19DQVAiIGNsYXNzPSJyb3czcHdkYSIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6dXJsKHN2Zy9zaGlmdC5zdmcpOyI+PC9kaXY+",
		aR = "PGRpdiBpZD0ia2JfY18yMCIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPno8L2Rpdj4=",
		bL = "PGRpdiBpZD0ia2JfY18yMSIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPng8L2Rpdj4=",
		bC = "PGRpdiBpZD0ia2JfY18yMiIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPmM8L2Rpdj4=",
		aH = "PGRpdiBpZD0ia2JfY18yMyIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPnY8L2Rpdj4=",
		bJ = "PGRpdiBpZD0ia2JfY18yNCIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPmI8L2Rpdj4=",
		au = "PGRpdiBpZD0ia2JfY18yNSIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPm48L2Rpdj4=",
		bz = "PGRpdiBpZD0ia2JfY18yNiIgY2xhc3M9InJvdzNwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPm08L2Rpdj4=",
		ai = "PGRpdiBpZD0ia2JfY19EIiBjbGFzcz0icm93M3B3ZGEiICBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTp1cmwoc3ZnL0RFTC5zdmcpOyI+PC9kaXY+",
		aO = "PC9kaXY+PGRpdiBjbGFzcz0icm93NCI+PGRpdiBpZD0ia2JfY19OIiBjbGFzcz0icm93NHB3ZGEiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnLzEyMy5zdmcpOyI+Lj8xMjM8L2Rpdj4=",
		cS = "PGRpdiBpZD0ia2JfY19TUEFDRSIgY2xhc3M9InJvdzRwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zcGFjZS5zdmcpOyI+c3BhY2U8L2Rpdj4=",
		de = "PGRpdiBpZD0ia2JfY19DTE9TRSIgY2xhc3M9InJvdzRwd2RhIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTp1cmwoc3ZnL3Nob3VxaS5zdmcpOyIgPjwvZGl2Pg==",
		dM = "PC9kaXY+PC9kaXY+PGRpdiBpZD0ibnVtYmVyX2tleWJvYXJkIiBzdHlsZT0id2lkdGg6MTAwJTsgaGVpZ2h0OjEwMCUgOyBkaXNwbGF5Om5vbmU7Ij4=",
		dO = "PGRpdiBjbGFzcz0icm93MSI+PGRpdiBpZD0ia2Jfbl8wIiBjbGFzcz0icm93MXB3ZCByb3dsZWZ0IGNoZyIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4xPC9kaXY+",
		bW = "PGRpdiBpZD0ia2Jfbl8xIiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+MjwvZGl2Pg==",
		cq = "PGRpdiBpZD0ia2Jfbl8yIiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+MzwvZGl2Pg==",
		cG = "PGRpdiBpZD0ia2Jfbl8zIiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+NDwvZGl2Pg==",
		dH = "PGRpdiBpZD0ia2Jfbl80IiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+NTwvZGl2Pg==",
		dp = "PGRpdiBpZD0ia2Jfbl81IiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+NjwvZGl2Pg==",
		cK = "PGRpdiBpZD0ia2Jfbl82IiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+NzwvZGl2Pg==",
		cj = "PGRpdiBpZD0ia2Jfbl83IiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+ODwvZGl2Pg==",
		dF = "PGRpdiBpZD0ia2Jfbl84IiBjbGFzcz0icm93MXB3ZCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+OTwvZGl2Pg==",
		bZ = "PGRpdiBpZD0ia2Jfbl85IiBjbGFzcz0icm93MXB3ZCByb3dyaWdodCBjaGciIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+MDwvZGl2PjwvZGl2PjxkaXYgY2xhc3M9InJvdzUiPg==",
		dw = "PGRpdiBpZD0ia2Jfbl8xMCIgY2xhc3M9InJvdzFwd2Qgcm93bGVmdCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4tPC9kaXY+",
		ck = "PGRpdiBpZD0ia2Jfbl8xMSIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+LzwvZGl2Pg==",
		du = "PGRpdiBpZD0ia2Jfbl8xMiIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+OjwvZGl2Pg==",
		cd = "PGRpdiBpZD0ia2Jfbl8xMyIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+OzwvZGl2Pg==",
		dg = "PGRpdiBpZD0ia2Jfbl8xNCIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+KDwvZGl2Pg==",
		cZ = "PGRpdiBpZD0ia2Jfbl8xNSIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+KTwvZGl2Pg==",
		cn = "PGRpdiBpZD0ia2Jfbl8xNiIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+JDwvZGl2Pg==",
		cu = "PGRpdiBpZD0ia2Jfbl8xNyIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+JjwvZGl2Pg==",
		cR = "PGRpdiBpZD0ia2Jfbl8xOCIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+QDwvZGl2Pg==",
		cJ = "PGRpdiBpZD0ia2Jfbl8xOSIgY2xhc3M9InJvdzFwd2Qgcm93cmlnaHQgcm93YWxvbmUiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+IjwvZGl2Pg==",
		cN = "PC9kaXY+PGRpdiBjbGFzcz0icm93MyI+PGRpdiBpZD0ia2Jfbl9TIiBjbGFzcz0icm93M3B3ZGMiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnLzEyMy5zdmcpOyI+Iys9PC9kaXY+",
		da = "PGRpdiBpZD0ia2Jfbl8yMSIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPi48L2Rpdj4=",
		dP = "PGRpdiBpZD0ia2Jfbl8yMiIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPiw8L2Rpdj4=",
		cL = "PGRpdiBpZD0ia2Jfbl8yMyIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPj88L2Rpdj4=",
		ci = "PGRpdiBpZD0ia2Jfbl8yNCIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPiE8L2Rpdj4=",
		cc = "PGRpdiBpZD0ia2Jfbl8yNSIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPic8L2Rpdj4=",
		dN = "PGRpdiBpZD0ia2Jfbl9EIiBjbGFzcz0icm93M3B3ZGMiICBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTp1cmwoc3ZnL0RFTC5zdmcpOyI+PC9kaXY+",
		cB = "PC9kaXY+PGRpdiBjbGFzcz0icm93NCI+PGRpdiBpZD0ia2Jfbl9DIiBjbGFzcz0icm93NHB3ZGEiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnLzEyMy5zdmcpOyI+QUJDPC9kaXY+",
		cT = "PGRpdiBpZD0ia2Jfbl9TUEFDRSIgY2xhc3M9InJvdzRwd2RiIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zcGFjZS5zdmcpOyI+c3BhY2U8L2Rpdj4=",
		dB = "PGRpdiBpZD0ia2Jfbl9DTE9TRSIgY2xhc3M9InJvdzRwd2RhIiAgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6dXJsKHN2Zy9zaG91cWkuc3ZnKTsiID48L2Rpdj4=",
		bb = "PC9kaXY+PC9kaXY+PGRpdiBpZD0ic3ltYmxlX2tleWJvYXJkIiAgc3R5bGU9IndpZHRoOjEwMCU7IGhlaWdodDoxMDAlIDsgZGlzcGxheTpub25lOyI+PGRpdiBjbGFzcz0icm93MSI+",
		aT = "PGRpdiBpZD0ia2Jfc18wIiBjbGFzcz0icm93MXB3ZCByb3dsZWZ0IiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPls8L2Rpdj4=",
		bd = "PGRpdiBpZD0ia2Jfc18xIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5dPC9kaXY+",
		aW = "PGRpdiBpZD0ia2Jfc18yIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij57PC9kaXY+",
		aV = "PGRpdiBpZD0ia2Jfc18zIiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij59PC9kaXY+",
		bQ = "PGRpdiBpZD0ia2Jfc180IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4jPC9kaXY+",
		bB = "PGRpdiBpZD0ia2Jfc181IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4lPC9kaXY+",
		aZ = "PGRpdiBpZD0ia2Jfc182IiBjbGFzcz0icm93MXB3ZCByb3dhbG9uZSIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij5ePC9kaXY+",
		bN = "PGRpdiBpZD0ia2Jfc183IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4qPC9kaXY+",
		aa = "PGRpdiBpZD0ia2Jfc184IiBjbGFzcz0icm93MXB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij4rPC9kaXY+",
		bj = "PGRpdiBpZD0ia2Jfc185IiBjbGFzcz0icm93MXB3ZCByb3dyaWdodCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvYW5qaWFuLnN2Zyk7Ij49PC9kaXY+",
		aD = "PC9kaXY+PGRpdiBjbGFzcz0icm93NSI+PGRpdiBpZD0ia2Jfc18xMCIgY2xhc3M9InJvdzFwd2Qgcm93bGVmdCByb3dsb25lbHkiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+XzwvZGl2Pg==",
		bg = "PGRpdiBpZD0ia2Jfc18xMSIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+XDwvZGl2Pg==",
		ae = "PGRpdiBpZD0ia2Jfc18xMiIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+fDwvZGl2Pg==",
		ax = "PGRpdiBpZD0ia2Jfc18xMyIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+fjwvZGl2Pg==",
		bH = "PGRpdiBpZD0ia2Jfc18xNCIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+KDwvZGl2Pg==",
		bu = "PGRpdiBpZD0ia2Jfc18xNSIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+KTwvZGl2Pg==",
		ay = "PGRpdiBpZD0ia2Jfc18xNiIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+JDwvZGl2Pg==",
		ao = "PGRpdiBpZD0ia2Jfc18xNyIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+JjwvZGl2Pg==",
		az = "PGRpdiBpZD0ia2Jfc18xOCIgY2xhc3M9InJvdzFwd2QiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+QDwvZGl2Pg==",
		bI = "PGRpdiBpZD0ia2Jfc18xOSIgY2xhc3M9InJvdzFwd2Qgcm93cmlnaHQgcm93YWxvbmUiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL2Fuamlhbi5zdmcpOyI+YDwvZGl2Pg==",
		aq = "PC9kaXY+PGRpdiBjbGFzcz0icm93MyI+PGRpdiBpZD0ia2Jfc19OIiBjbGFzcz0icm93M3B3ZGMiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnLzEyMy5zdmcpOyI+MTIzPC9kaXY+",
		aN = "PGRpdiBpZD0ia2Jfc18yMSIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPi48L2Rpdj4=",
		aw = "PGRpdiBpZD0ia2Jfc18yMiIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPiw8L2Rpdj4=",
		bp = "PGRpdiBpZD0ia2Jfc18yMyIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPj88L2Rpdj4=",
		af = "PGRpdiBpZD0ia2Jfc18yNCIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPiE8L2Rpdj4=",
		bk = "PGRpdiBpZD0ia2Jfc18yNSIgY2xhc3M9InJvdzNwd2RkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9hbmppYW4uc3ZnKTsiPic8L2Rpdj4=",
		aK = "PGRpdiBpZD0ia2Jfc19EIiBjbGFzcz0icm93M3B3ZGMiICBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTp1cmwoc3ZnL0RFTC5zdmcpOyI+PC9kaXY+",
		bw = "PC9kaXY+PGRpdiBjbGFzcz0icm93NCI+PGRpdiBpZD0ia2Jfc19DIiBjbGFzcz0icm93NHB3ZGEiIHN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnLzEyMy5zdmcpOyI+QUJDPC9kaXY+",
		as = "PGRpdiBpZD0ia2Jfc19TUEFDRSIgY2xhc3M9InJvdzRwd2RiInN0eWxlPSJiYWNrZ3JvdW5kLWltYWdlOiB1cmwoc3ZnL3NwYWNlLnN2Zyk7IiA+c3BhY2U8L2Rpdj4=",
		bO = "PGRpdiBpZD0ia2Jfc19DTE9TRSIgY2xhc3M9InJvdzRwd2RhIiAgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6dXJsKHN2Zy9zaG91cWkuc3ZnKTsiID48L2Rpdj4=",
		aY = "PC9kaXY+PC9kaXY+PGRpdiBpZD0icHVyZW51bWJlcl9rZXlib2FyZCIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPjxkaXYgY2xhc3M9InJvdzEiPg==",
		aL = "PGRpdiBpZD0ia2JfcF8wIiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij4xPC9kaXY+",
		bf = "PGRpdiBpZD0ia2JfcF8xIiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij4yPC9kaXY+",
		bK = "PGRpdiBpZD0ia2JfcF8yIiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij4zPC9kaXY+",
		bv = "PC9kaXY+PGRpdiBjbGFzcz0icm93NSI+PGRpdiBpZD0ia2JfcF8zIiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij40PC9kaXY+",
		aB = "PGRpdiBpZD0ia2JfcF80IiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij41PC9kaXY+",
		bc = "PGRpdiBpZD0ia2JfcF81IiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij42PC9kaXY+",
		bV = "PC9kaXY+PGRpdiBjbGFzcz0icm93NSI+PGRpdiBpZD0ia2JfcF82IiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij43PC9kaXY+",
		aF = "PGRpdiBpZD0ia2JfcF83IiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij44PC9kaXY+",
		ad = "PGRpdiBpZD0ia2JfcF84IiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTogdXJsKHN2Zy9zaHV6aV8xLnN2Zyk7Ij45PC9kaXY+",
		bP = "PC9kaXY+PGRpdiBjbGFzcz0icm93NSI+PGRpdiBpZD0ia2JfcF9EIiBjbGFzcz0icHdkIiBzdHlsZT0iYmFja2dyb3VuZC1pbWFnZTp1cmwoc3ZnL3NodXppX2RlbGV0ZV8xLnN2Zyk7IiA+PC9kaXY+",
		an = "PGRpdiBpZD0ia2JfcF8xMCIgY2xhc3M9InB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6IHVybChzdmcvc2h1emlfMS5zdmcpOyI+MDwvZGl2Pg==",
		aJ = "PGRpdiBpZD0ia2JfcF9DTE9TRSIgY2xhc3M9InB3ZCIgc3R5bGU9ImJhY2tncm91bmQtaW1hZ2U6dXJsKHN2Zy9zaHV6aV9zaG91cWlfMS5zdmcpOyIgPjwvZGl2Pg==",
		bF = "PC9kaXY+PC9kaXY+PGRpdiBzdHlsZT0iY2xlYXI6IGJvdGg7Ij48L2Rpdj48YXVkaW8gIHByZWxvYWQ9ImxvYWQiPjwvZGl2Pg==",
		by = "",
		aM = "";
	var fkb = bY + J(ct) + J(dq) + J(aQ) + J(bG) + J(ap) + J(aP) + J(cg) + J(df) + J(dc) + J(cz);
	fkb += J(bX) + J(cF) + J(cW) + J(ca) + J(bD) + J(be) + J(bx) + J(aG) + J(ak) + J(ab);
	fkb += J(aC) + J(aR) + J(bL) + J(bC) + J(aH) + J(bJ) + J(au) + J(bz) + J(ai) + J(aO);
	fkb += J(cS) + J(de) + J(dM) + J(dO) + J(bW) + J(cq) + J(cG) + J(dH) + J(dp) + J(cK);
	fkb += J(cj) + J(dF) + J(bZ) + J(dw) + J(ck) + J(du) + J(cd) + J(dg) + J(cZ) + J(cn);
	fkb += J(cu) + J(cR) + J(cJ) + J(cN) + J(da) + J(dP) + J(cL) + J(ci) + J(cc) + J(dN);
	fkb += J(cB) + J(cT) + J(dB) + J(bb) + J(aT) + J(bd) + J(aW) + J(aV) + J(bQ) + J(bB);
	fkb += J(aZ) + J(bN) + J(aa) + J(bj) + J(aD) + J(bg) + J(ae) + J(ax) + J(bH) + J(bu);
	fkb += J(ay) + J(ao) + J(az) + J(bI) + J(aq) + J(aN) + J(aw) + J(bp) + J(af) + J(bk);
	fkb += J(aK) + J(bw) + J(as) + J(bO) + J(aY) + J(aL) + J(bf) + J(bK) + J(bv) + J(aB);
	fkb += J(bc) + J(bV) + J(aF) + J(ad) + J(bP) + J(an) + J(aJ) + J(bF) + J(by) + J(aM);
	$(document.body).append(fkb);
	ago = $("body").height();
	winHeight = $(window).height();
	if (this.settings.kbType != 0) {
		$("#purenumber_keyboard").css("display", "block");
		$("#char_keyboard").css("display", "none");
		$("#number_keyboard").css("display", "none");
		$("#symble_keyboard").css("display", "none");
	} else {
		$("#purenumber_keyboard").css("display", "none");
		$("#char_keyboard").css("display", "block");
		$("#number_keyboard").css("display", "none");
		$("#symble_keyboard").css("display", "none");
	}
	var V = this;
	var curid = "#" + this.settings.id;
	var justic = function() {
			var r1 = new RegExp("row\\d");
			var r2 = new RegExp("_keyboard");
			$(curid).contents("div").filter(function() {
				if (r2.test(this.id)) {
					$("#" + this.id).contents("div").filter(function() {
						if (r1.test(this.className)) {
							$(this).contents("div").filter(function() {
								var h = $("#" + this.id).height();
								$("#" + this.id).css("lineHeight", h + "px");
							});
						}
					});
				}
			});
		};
	var ml = "-" + $("body").css("margin-left");
	var R = 0;
	var curh = parseInt($(curid).css("height"));
	if ((V.orientation() == 90) || (V.orientation() == -90)) {
		var bn = Math.max(window.innerHeight, document.documentElement.clientHeight);
		R = bn * V.proportion();
		if (R < curh) {
			R = curh;
		}
		$(curid).css("height", R);
		$("#purenumber_keyboard").css("height", R);
		$("#char_keyborad").css("height", R);
		$("#number_keyborad").css("height", R);
		$("#symble_keyboard").css("height", R);
	} else {
		var bn = Math.max(window.innerHeight, document.documentElement.clientHeight);
		R = bn * V.proportion();
		if (R < curh) {
			R = curh;
		}
		$(curid).css("height", R);
		$("#purenumber_keyboard").css("height", R);
		$("#char_keyboard").css("height", R);
		$("#number_keyboard").css("height", R);
		$("#symble_keyboard").css("height", R);
		var r1 = new RegExp("row\\d");
		var r2 = new RegExp("_keyboard");
		$(curid).contents("div").filter(function() {
			if (r2.test(this.id)) {
				$("#" + this.id).contents("div").filter(function() {
					if (r1.test(this.className)) {
						$(this).contents("div").filter(function() {
							var h = 0.23 * R;
							$("#" + this.id).css({
								height: h + "px",
								lineHeight: h + "px"
							});
						});
					}
				});
			}
		});
	}
	if (!this.init) {
		var regkb = new RegExp("_keyboard");
		var reName = new RegExp("kb_");
		var regrow = new RegExp("row\\d");
		var dealbt = function(cid) {
				var event = 0;
				if (reName.test(cid)) {
					var regpn = /_p_/;
					var regn = /_n_/;
					var regc = /_c_/;
					var regs = /_s_/;
					if (regpn.test(cid)) {
						if ((cid != "kb_p_D") && (cid != "kb_p_CLOSE")) {
							$("#" + cid).on("touchstart", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									$("#" + cid).css("background-image", "url(svg/shuzi_2.svg)");
								};
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								$("#" + cid).css("background-image", "url(svg/shuzi_1.svg)");
							});
						} else if (cid == "kb_p_D") {
							var key = this.innerText;
							var event = 2;
							var delInter;
							var dels = [];
							$("#" + cid).on("touchstart", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									$("#" + cid).css("background-image", "url(svg/shuzi_delete_2.svg)");
								}
								V.settings.pg.aA(event, "");
								startT = new Date().getTime();
								delInter = window.setInterval(function() {
									endT = new Date().getTime();
									var x = endT - startT;
									if (x > 500) {
										var input = document.getElementById(V.settings.pg.settings.id);
										var xI = setInterval(function() {
											V.settings.pg.O = V.settings.pg.O.substr(0, V.settings.pg.O.length - 1);
											V.settings.pg.bM = V.settings.pg.bM.substr(0, V.settings.pg.bM.length - 1);
											input.value = input.value.substr(0, V.settings.pg.O.length - 1);
										}, 50);
										dels.push(xI);
										clearInterval(delInter);
									}
								}, 1);
								e.preventDefault();
								return false;
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								$("#" + cid).css("background-image", "url(svg/shuzi_delete_1.svg)");
								clearInterval(delInter);
								for (var int = 0; int < dels.length; int++) {
									clearInterval(dels[int]);
								}
								dels = [];
								var input = document.getElementById(V.settings.pg.settings.id);
								var xingStr = "";
								for (var i = 0; i < V.settings.pg.O.length; i++) {
									xingStr += "*";
								}
								input.value = xingStr;
								e.preventDefault();
								return false;
							});
						};
						$("#" + cid).on("touchstart", function(e) {
							if (cid == "kb_p_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi_2.svg)");
							}
						});
						$("#" + cid).on("touchend touchcancel", function(e) {
							if (cid == "kb_p_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi.svg)");
							}
						});
						$("#" + cid).on("tap", function(e) {
							var key = this.innerText;
							if (cid == "kb_p_SPACE") {
								return;
							} else if (cid == "kb_p_D") {
								event = 2;
							} else if (cid == "kb_p_CLOSE") {
								pm = reciveId.substring(reciveId.length - 1, reciveId.length);
								if (eval("(" + 'passGuard' + pm + ")").O == "") {
									$("#" + reciveId).attr('placeholder', arrPlace[pm - 1])
								}
								var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
								if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
									eval("(" + 'passGuard' + pm + ")").settings.callBack()
								} else {
									eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
								}
								add++;
								cs = 1;
								if ((window.orientation == 90) || (window.orientation == -90)) {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								} else {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								}
								$(curid).removeClass("pwdkeyboard").addClass("pwdkeyboardout");
								document.querySelector(curid).addEventListener("webkitAnimationEnd", V.handler, false);
								event = 1;
							} else {}
							e.preventDefault();
							V.settings.pg.aA(event, key.charCodeAt() ^ V.settings.odd);
							if (V.settings.chaosMode == 2 && event == 0) {
								var arr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
								arr = V.bA(arr);
								var chars = $("#purenumber_keyboard")[0].querySelectorAll(".pwd");
								var charst = [];
								for (var j = 0, i = 0; j < chars.length; j++) {
									if (chars[j].id == "kb_p_CLOSE" || chars[j].id == "kb_p_D") continue;
									i++;
									charst.push(chars[j]);
								}
								for (var j = 0; j < charst.length; j++) {
									charst[j].innerHTML = arr[j];
								}
							}
						});
					}
					if (regc.test(cid)) {
						if ((cid != "kb_c_D") && (cid != "kb_c_CLOSE") && (cid != "kb_c_CAP")) {
							var mun = 1;
							$("#" + cid).on("touchstart", function(e) {
								var $fd = $(this);
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if (/_SPACE/i.test(cid)) {
										$fd.css("background-image", "url(svg/space_2.svg)");
									} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
										$fd.css("background-image", "url(svg/123_2.svg)");
									} else {
										if (V.settings.pressStatus == 1) {
											$(".fd").remove();
											var Html = $(this).html();
											$fd.append($("<div class='fd'></div>"));
											$fd.css({
												position: "relative"
											});
											if ($fd.hasClass("rowleft")) {
												var img = new Image;
												img.src = 'svg/dianji_left.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else if ($fd.hasClass("rowright")) {
												var img = new Image;
												img.src = 'svg/dianji_right.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														right: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else {
												var img = new Image;
												img.src = 'svg/dianji.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: "-20%",
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											}
										} else if (V.settings.pressStatus == 2) {
											$("#" + cid).css("background-image", "url(svg/anjian_2.svg)");
										}
									}
								}
								e.preventDefault();
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (/_SPACE/i.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/space.svg)");
								} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/123.svg)");
								} else {
									setTimeout(function() {
										$(".fd").eq(0).remove();
									}, 100);
									$("#" + cid).css("background-image", "url(svg/anjian.svg)");
								};
								e.preventDefault();
							});
						} else if (cid == "kb_c_D") {
							var key = this.innerText;
							var event = 2;
							var delInter;
							var dels = [];
							$("#" + cid).on("touchstart", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H_2.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL_2.svg)");
									}
								}
								V.settings.pg.aA(event, "");
								startT = new Date().getTime();
								delInter = window.setInterval(function() {
									endT = new Date().getTime();
									var x = endT - startT;
									if (x > 500) {
										var input = document.getElementById(V.settings.pg.settings.id);
										var xI = setInterval(function() {
											V.settings.pg.O = V.settings.pg.O.substr(0, V.settings.pg.O.length - 1);
											V.settings.pg.bM = V.settings.pg.bM.substr(0, V.settings.pg.bM.length - 1);
											input.value = input.value.substr(0, V.settings.pg.O.length - 1);
										}, 50);
										dels.push(xI);
										clearInterval(delInter);
									}
								}, 1);
								e.preventDefault();
								return false;
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL.svg)");
									}
								}
								clearInterval(delInter);
								for (var int = 0; int < dels.length; int++) {
									clearInterval(dels[int]);
								}
								dels = [];
								var input = document.getElementById(V.settings.pg.settings.id);
								var xingStr = "";
								for (var i = 0; i < V.settings.pg.O.length; i++) {
									xingStr += "*";
								}
								input.value = xingStr;
								e.preventDefault();
								return false;
							});
						}
						if (cid == "kb_c_CAP") {
							var action;
							$("#" + cid).bind('touchend touchcancel', function(event) {
								$(".fd").remove();
								var now = new Date().getTime();
								var lastTouch = $(this).data('lastTouch') || now + 1;
								var delta = now - lastTouch;
								clearTimeout(action);
								if (delta < 600 && delta > 0) {
									V.dt = V.caps = true;
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$(this).css("background-image", "url(svg/shift_DS_H.svg)");
									} else {
										$(this).css("background-image", "url(svg/shift_DS.svg)");
									}
									$("#char_keyboard").contents("div").filter(function() {
										$(this).contents("div").filter(function() {
											var c = this.innerText;
											if (c.length == 1) {
												this.innerText = c.toUpperCase();
											}
										});
									});
								} else {
									$(this).data('lastTouch', now);
									action = setTimeout(function(e) {
										clearTimeout(action);
									}, 600, [event]);
								}
								$(this).data('lastTouch', now);
							});
							event = 7;
						}
						$("#" + cid).on("touchstart", function(e) {
							if (cid == "kb_c_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi_2.svg)");
							}
							e.preventDefault();
						});
						$("#" + cid).on("touchend touchcancel", function(e) {
							if (cid == "kb_c_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi.svg)");
							}
						});
						$("#" + cid).on("tap", function(e) {
							var key = this.innerText;
							if (cid != "kb_c_D") {
								if (cid == "kb_c_SPACE") {
									return;
								} else if (cid == "kb_c_CLOSE") {
									pm = reciveId.substring(reciveId.length - 1, reciveId.length);
									if (eval("(" + 'passGuard' + pm + ")").O == "") {
										$("#" + reciveId).attr('placeholder', arrPlace[pm - 1])
									}
									var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
									if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
										eval("(" + 'passGuard' + pm + ")").settings.callBack()
									} else {
										eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
									};
									add++;
									cs = 1;
									if ((window.orientation == 90) || (window.orientation == -90)) {
										$("body").css({
											position: "relative",
											left: 0,
											top: 0,
											transition: "all 0.3s"
										})
									} else {
										$("body").css({
											position: "relative",
											left: 0,
											top: 0,
											transition: "all 0.3s"
										})
									}
									$(curid).removeClass("pwdkeyboard").addClass("pwdkeyboardout");
									document.querySelector(curid).addEventListener("webkitAnimationEnd", V.handler, false);
									event = 1;
								} else if (cid == "kb_c_CAP") {
									if (!V.dt) {
										if (V.caps) {
											V.caps = false;
											V.shift = false;
											if ((V.orientation() == 90) || (V.orientation() == -90)) {
												$(this).css("background-image", "url(svg/shift_H.svg)");
											} else {
												$(this).css("background-image", "url(svg/shift.svg)");
											}
										} else {
											if (V.shift) {
												V.shift = false;
												if ((V.orientation() == 90) || (V.orientation() == -90)) {
													$(this).css("background-image", "url(svg/shift_H.svg)");
												} else {
													$(this).css("background-image", "url(svg/shift.svg)");
												}
											} else {
												V.shift = true;
												if ((V.orientation() == 90) || (V.orientation() == -90)) {
													$(this).css("background-image", "url(svg/shift_D_H.svg)");
												} else {
													$(this).css("background-image", "url(svg/shift_D.svg)");
												}
											}
											if (V.caps) {
												V.caps = false;
												if ((V.orientation() == 90) || (V.orientation() == -90)) {
													$(this).css("background-image", "url(svg/shift_H.svg)");
												} else {
													$(this).css("background-image", "url(svg/shift.svg)");
												}
											}
										}
									} else {
										V.dt = false;
									}
									if (V.caps || V.shift) {
										$("#char_keyboard").contents("div").filter(function() {
											$(this).contents("div").filter(function() {
												var c = this.innerText;
												if (c.length == 1) {
													this.innerText = c.toUpperCase();
												} else if (c.length == 2) {
													this.innerText = c.substring(0, 1).toUpperCase();
												}
											});
										});
									} else {
										$("#char_keyboard").contents("div").filter(function() {
											$(this).contents("div").filter(function() {
												var c = this.innerText;
												if (c.length == 1) {
													this.innerText = c.toLowerCase();
												} else if (c.length == 2) {
													this.innerText = c.substring(0, 1).toLowerCase();
												}
											});
										});
									}
								} else if (cid == "kb_c_N") {
									$("#char_keyboard").css("display", "none");
									$("#number_keyboard").css("display", "block");
									$("#symble_keyboard").css("display", "none");
									$("#purenumber_keyboard").css("display", "none");
									event = 4;
									justic();
								} else {
									if (!V.caps && V.shift) {
										setTimeout(function() {
											$("#char_keyboard").contents("div").filter(function() {
												$(this).contents("div").filter(function() {
													var c = this.innerText;
													if (c.length == 1) {
														this.innerText = c.toLowerCase();
													} else if (c.length == 2) {
														this.innerText = c.substring(0, 1).toLowerCase();
													}
												});
											});
										}, 100);
										V.shift = false;
										if ((V.orientation() == 90) || (V.orientation() == -90)) {
											$("#kb_c_CAP").css("background-image", "url(svg/shift_H.svg)");
										} else {
											$("#kb_c_CAP").css("background-image", "url(svg/shift.svg)");
										}
									}
								}
								e.preventDefault();
								V.settings.pg.aA(event, key.charCodeAt() ^ V.settings.odd);
							}
							if (V.settings.chaosMode == 2 && event == 0) {
								var arr = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm'];
								arr = V.bA(arr, V.caps);
								var chars = $("#char_keyboard")[0].querySelectorAll(".row1pwd,.row2pwd,.row3pwdb");
								setTimeout(function() {
									for (var j = 0; j < chars.length; j++) {
										chars[j].innerHTML = arr[j];
									}
								}, 100)
							}
						});
					}
					if (regn.test(cid)) {
						if ((cid != "kb_n_D") && (cid != "b_n_CLOSE")) {
							$("#" + cid).on("touchstart", function(e) {
								var $fd = $(this);
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if (/_SPACE/i.test(cid)) {
										$fd.css("background-image", "url(svg/space_2.svg)");
									} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
										$fd.css("background-image", "url(svg/123_2.svg)");
									} else {
										if (V.settings.pressStatus == 1) {
											$(".fd").remove();
											var Html = $(this).html();
											$fd.append($("<div class='fd'></div>"));
											$fd.css({
												position: "relative"
											});
											if ($fd.hasClass("rowleft")) {
												var img = new Image;
												img.src = 'svg/dianji_left.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else if ($fd.hasClass("rowright")) {
												var img = new Image;
												img.src = 'svg/dianji_right.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														right: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else {
												var img = new Image;
												img.src = 'svg/dianji.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: "-20%",
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											}
										} else if (V.settings.pressStatus == 2) {
											$("#" + cid).css("background-image", "url(svg/anjian_2.svg)");
										}
									}
								}
								e.preventDefault();
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (/_SPACE/i.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/space.svg)");
								} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/123.svg)");
								} else {
									$("#" + cid).css("background-image", "url(svg/anjian.svg)");
									setTimeout(function() {
										$(".fd").remove();
									}, 100);
								};
								e.preventDefault();
							});
						} else if (cid == "kb_n_D") {
							var key = this.innerText;
							var event = 2;
							var delInter;
							var dels = [];
							$("#" + cid).on("touchstart", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H_2.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL_2.svg)");
									}
								}
								V.settings.pg.aA(event, "");
								startT = new Date().getTime();
								delInter = window.setInterval(function() {
									endT = new Date().getTime();
									var x = endT - startT;
									if (x > 500) {
										var input = document.getElementById(V.settings.pg.settings.id);
										var xI = setInterval(function() {
											V.settings.pg.O = V.settings.pg.O.substr(0, V.settings.pg.O.length - 1);
											V.settings.pg.bM = V.settings.pg.bM.substr(0, V.settings.pg.bM.length - 1);
											input.value = input.value.substr(0, V.settings.pg.O.length - 1);
										}, 50);
										dels.push(xI);
										clearInterval(delInter);
									}
								}, 1);
								e.preventDefault();
								return false;
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL.svg)");
									}
								}
								clearInterval(delInter);
								for (var int = 0; int < dels.length; int++) {
									clearInterval(dels[int]);
								}
								dels = [];
								var input = document.getElementById(V.settings.pg.settings.id);
								var xingStr = "";
								for (var i = 0; i < V.settings.pg.O.length; i++) {
									xingStr += "*";
								}
								input.value = xingStr;
								e.preventDefault();
								return false;
							});
						};
						$("#" + cid).on("touchstart", function(e) {
							if (cid == "kb_n_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi_2.svg)");
							};
							e.preventDefault()
						});
						$("#" + cid).on("touchend touchcancel", function(e) {
							if (cid == "kb_n_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi.svg)");
							}
						});
						$("#" + cid).on("tap", function(e) {
							var key = this.innerText;
							if (cid == "kb_n_SPACE") {
								return;
							} else if (cid == "kb_n_D") {
								event = 2;
							} else if (cid == "kb_n_CLOSE") {
								pm = reciveId.substring(reciveId.length - 1, reciveId.length);
								if (eval("(" + 'passGuard' + pm + ")").O == "") {
									$("#" + reciveId).attr('placeholder', arrPlace[pm - 1])
								}
								var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
								if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
									eval("(" + 'passGuard' + pm + ")").settings.callBack()
								} else {
									eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
								};
								add++;
								cs = 1;
								if ((window.orientation == 90) || (window.orientation == -90)) {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								} else {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								}
								$(curid).removeClass("pwdkeyboard").addClass("pwdkeyboardout");
								document.querySelector(curid).addEventListener("webkitAnimationEnd", V.handler, false);
								event = 1;
							} else if (cid == "kb_n_S") {
								$("#char_keyboard").css("display", "none");
								$("#number_keyboard").css("display", "none");
								$("#symble_keyboard").css("display", "block");
								$("#purenumber_keyboard").css("display", "none");
								event = 6;
								justic();
							} else if (cid == "kb_n_C") {
								$("#char_keyboard").css("display", "block");
								$("#number_keyboard").css("display", "none");
								$("#symble_keyboard").css("display", "none");
								$("#purenumber_keyboard").css("display", "none");
								event = 5;
								justic();
							} else {} if (e.target.className.indexOf("chg") > -1) {
								if (V.settings.chaosMode == 2 && event == 0) {
									var arr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
									arr = V.bA(arr);
									var charst = [];
									var chars = $("#number_keyboard > .row1")[0].querySelectorAll(".row1pwd");
									setTimeout(function() {
										for (var j = 0, i = 0; j < chars.length; j++) {
											if (chars[j].id == "kb_n_CLOSE" || chars[j].id == "kb_n_D") continue;
											i++;
											charst.push(chars[j]);
										}
										for (var j = 0; j < charst.length; j++) {
											charst[j].innerHTML = arr[j];
										}
									}, 100)
								}
							};
							e.preventDefault();
							V.settings.pg.aA(event, key.charCodeAt() ^ V.settings.odd);
						});
					}
					if (regs.test(cid)) {
						if ((cid != "kb_s_D") && (cid != "kb_s_CLOSE")) {
							$("#" + cid).on("touchstart", function(e) {
								var $fd = $(this);
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if (/_SPACE/i.test(cid)) {
										$fd.css("background-image", "url(svg/space_2.svg)");
									} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
										$fd.css("background-image", "url(svg/123_2.svg)");
									} else {
										if (V.settings.pressStatus == 1) {
											$(".fd").remove();
											var Html = $(this).html();
											$fd.append($("<div class='fd'></div>"));
											$fd.css({
												position: "relative"
											});
											if ($fd.hasClass("rowleft")) {
												var img = new Image;
												img.src = 'svg/dianji_left.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else if ($fd.hasClass("rowright")) {
												var img = new Image;
												img.src = 'svg/dianji_right.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														right: 0,
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											} else {
												var img = new Image;
												img.src = 'svg/dianji.svg';
												img.onload = function() {
													$(".fd").eq(0).html(Html);
													$(".fd").eq(0).css({
														backgroundImage: 'url(' + img.src + ')',
														position: "absolute",
														width: "140%",
														height: R * 0.4 + "px",
														left: "-20%",
														bottom: "0px",
														textAlign: "center",
														fontSize: "1.5em",
														zIndex: "999",
														lineHeight: R * 0.25 + "px"
													});
												}
											}
										} else if (V.settings.pressStatus == 2) {
											$("#" + cid).css("background-image", "url(svg/anjian_2.svg)");
										}
									}
								}
								e.preventDefault();
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (/_SPACE/i.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/space.svg)");
								} else if (/_N/.test(cid) || /_C/.test(cid) || /_S/.test(cid)) {
									$("#" + cid).css("background-image", "url(svg/123.svg)");
								} else {
									$("#" + cid).css("background-image", "url(svg/anjian.svg)");
									setTimeout(function() {
										$(".fd").remove();
									}, 100);
								};
								e.preventDefault();
							});
						} else if (cid == "kb_s_D") {
							var key = this.innerText;
							var event = 2;
							var delInter;
							var dels = [];
							$("#" + cid).on("touchstart", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H_2.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL_2.svg)");
									}
								}
								V.settings.pg.aA(event, "");
								startT = new Date().getTime();
								delInter = window.setInterval(function() {
									endT = new Date().getTime();
									var x = endT - startT;
									if (x > 500) {
										var input = document.getElementById(V.settings.pg.settings.id);
										var xI = setInterval(function() {
											V.settings.pg.O = V.settings.pg.O.substr(0, V.settings.pg.O.length - 1);
											V.settings.pg.bM = V.settings.pg.bM.substr(0, V.settings.pg.bM.length - 1);
											input.value = input.value.substr(0, V.settings.pg.O.length - 1);
										}, 50);
										dels.push(xI);
										clearInterval(delInter);
									}
								}, 1);
								e.preventDefault();
								return false;
							});
							$("#" + cid).on("touchend touchcancel", function(e) {
								if (V.settings.pressStatus == 1 || V.settings.pressStatus == 2) {
									if ((V.orientation() == 90) || (V.orientation() == -90)) {
										$("#" + cid).css("background-image", "url(svg/DEL_H.svg)");
									} else {
										$("#" + cid).css("background-image", "url(svg/DEL.svg)");
									}
								}
								clearInterval(delInter);
								for (var int = 0; int < dels.length; int++) {
									clearInterval(dels[int]);
								}
								dels = [];
								var input = document.getElementById(V.settings.pg.settings.id);
								var xingStr = "";
								for (var i = 0; i < V.settings.pg.O.length; i++) {
									xingStr += "*";
								}
								input.value = xingStr;
								e.preventDefault();
								return false;
							});
						};
						$("#" + cid).on("touchstart", function(e) {
							if (cid == "kb_s_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi_2.svg)");
							};
							e.preventDefault();
						});
						$("#" + cid).on("touchend touchcancel", function(e) {
							if (cid == "kb_s_CLOSE" && (V.settings.pressStatus == 1 || V.settings.pressStatus == 2)) {
								$("#" + cid).css("background-image", "url(svg/shouqi.svg)");
							};
						});
						$("#" + cid).on("tap", function(e) {
							var key = this.innerText;
							if (cid == "kb_s_SPACE") {
								return;
							} else if (cid == "kb_s_D") {
								event = 2;
							} else if (cid == "kb_s_CLOSE") {
								pm = reciveId.substring(reciveId.length - 1, reciveId.length);
								if (eval("(" + 'passGuard' + pm + ")").O == "") {
									$("#" + reciveId).attr('placeholder', arrPlace[pm - 1])
								}
								var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
								if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
									eval("(" + 'passGuard' + pm + ")").settings.callBack()
								} else {
									eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
								};
								add++;
								cs = 1;
								if ((window.orientation == 90) || (window.orientation == -90)) {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								} else {
									$("body").css({
										position: "relative",
										left: 0,
										top: 0,
										transition: "all 0.3s"
									})
								}
								$(curid).removeClass("pwdkeyboard").addClass("pwdkeyboardout");
								document.querySelector(curid).addEventListener("webkitAnimationEnd", V.handler, false);
								event = 1;
							} else if (cid == "kb_s_N") {
								$("#char_keyboard").css("display", "none");
								$("#number_keyboard").css("display", "block");
								$("#symble_keyboard").css("display", "none");
								$("#purenumber_keyboard").css("display", "none");
								event = 4;
								justic();
							} else if (cid == "kb_s_C") {
								$("#char_keyboard").css("display", "block");
								$("#number_keyboard").css("display", "none");
								$("#symble_keyboard").css("display", "none");
								$("#purenumber_keyboard").css("display", "none");
								event = 5;
								justic();
							} else {}
							e.preventDefault();
							V.settings.pg.aA(event, key.charCodeAt() ^ V.settings.odd);
						});
					}
				}
			};
		$(curid).contents("div").filter(function() {
			if (regkb.test(this.id)) {
				$("#" + this.id).contents("div").filter(function() {
					if (regrow.test(this.className)) {
						$(this).contents("div").filter(function() {
							dealbt(this.id);
						});
					} else {
						dealbt(this.id);
					}
				});
			}
		});
		$(document).on("touchend touchcancel", function(e) {
			setTimeout(function() {
				$(".fd").remove();
			}, 100);
		});
		$(document).on("touchstart", function(e) {
			var fd;
			var container = $(curid);
			var input = $("#" + V.settings.id);
			if (!container.is(e.target) && container.has(e.target).length === 0 && !input.is(e.target)) {
				if (e.target.className.indexOf("default") > -1 || e.target.className == "fd") {
					$(".fd").remove();
					return;
				} else {
					if (reciveId != "") {
						pm = reciveId.substring(reciveId.length - 1, reciveId.length);
						if (eval("(" + 'passGuard' + pm + ")").O == "") {
							$("#" + reciveId).attr('placeholder', arrPlace[pm - 1])
						}
						if (add == 1) {
							var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
							if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
								eval("(" + 'passGuard' + pm + ")").settings.callBack()
							} else {
								eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
							}
							add++;
						}
					}
					cs = 1;
					var b = container.is(':visible');
					if (b) {
						if ((window.orientation == 90) || (window.orientation == -90)) {
							$("body").css({
								position: "relative",
								left: 0,
								top: 0,
								transition: "all 0.3s"
							})
						} else {
							$("body").css({
								position: "relative",
								left: 0,
								top: 0,
								transition: "all 0.3s"
							})
						}
						container.removeClass("pwdkeyboard").addClass("pwdkeyboardout");
						document.querySelector(curid).addEventListener("webkitAnimationEnd", V.handler, false);
						event = 1;
						V.settings.pg.aA(event, '0'.charCodeAt() ^ V.settings.odd);
					}
				}
			};
		});
		window.addEventListener("orientationchange", function() {
			$(".fd").hide();
			var intel = aj ? 300 : 0;
			if (/ OPR/i.test(u) || / OPiOS/i.test(u) || /MicroMessenger/i.test(u)) {
				V.activeobj = document.activeElement;
				if (V.activeobj != undefined) {
					V.activeobj.blur();
					setTimeout(function() {
						if (V.activeobj != undefined) {
							V.activeobj = undefined;
						}
					}, 300);
				}
			};
			if ($(curid).is(':visible')) {
				$(curid).hide();
				setTimeout(function() {
					V.show();
					$(curid).contents("div").filter(function() {
						var reg1 = new RegExp("row\\d");
						var reg2 = new RegExp("_keyboard");
						if (reg2.test(this.id)) {
							$("#" + this.id).contents("div").filter(function() {
								if (reg1.test(this.className)) {
									$(this).contents("div").filter(function() {
										var h = $("#" + this.id).height();
										$("#" + this.id).css("line-height", h + "px");
										var s = $("#" + this.id).css("background-image");
										if (/anjian_1.svg/i.test(s)) {
											$("#" + this.id).css("background-image", "url(svg/anjian.svg)");
										}
									});
								}
							});
						}
					});
				}, 500);
			}
		});
		this.init = true;
	}
};
keyBoard.prototype.bA = function(data, flag) {;
	var arrlen = data.length;;
	var try1 = new Array();
	for (var i = 0; i < arrlen; i++) {try1[i] = i;
	};
	var try2 = new Array();
	for (var i = 0; i < arrlen; i++) {try2[i] = try1.splice(Math.floor(Math.random() * try1.length), 1);
	};
	var try3 = new Array();
	for (var i = 0; i < arrlen; i++) {
		if (flag) {try3[i] = data[try2[i]].toUpperCase();
		} else {
			try3[i] = data[try2[i]].toLowerCase();
		}
	}
	return try3;
};
keyBoard.prototype.getheight = function() {
	var h1 = (document.documentElement.clientHeight);
	var h2 = (window.innerHeight);
	alert(document.documentElement.clientHeight);
	alert(window.innerHeight);
	alert(h1);
	alert(h2);
	if (document.documentElement.clientHeight > window.innerHeight) return document.documentElement.clientHeight;
	else return window.innerHeight;
};
keyBoard.prototype.show = function() {
	var V = this;
	var curid = "#" + this.settings.id;
	if ((V.settings.chaosMode == 1 || V.settings.chaosMode == 2) && V.settings.kbType == 0) {
		var arr = ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'z', 'x', 'c', 'v', 'b', 'n', 'm'];
		arr = V.bA(arr);
		var chars = $("#char_keyboard")[0].querySelectorAll(".row1pwd,.row2pwd,.row3pwdb");
		if (V.caps || V.shift) {
			for (var j = 0; j < chars.length; j++) {
				chars[j].innerHTML = arr[j].toUpperCase();
			}
		} else {
			for (var j = 0; j < chars.length; j++) {
				chars[j].innerHTML = arr[j];
			}
		}
	}
	if ((V.settings.chaosMode == 1 || V.settings.chaosMode == 2) && V.settings.kbType == 1) {
		var arr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'];
		arr = V.bA(arr);
		var chars = $("#purenumber_keyboard")[0].querySelectorAll(".pwd");
		var charst = [];
		for (var j = 0, i = 0; j < chars.length; j++) {
			if (chars[j].id == "kb_p_CLOSE" || chars[j].id == "kb_p_D") continue;
			i++;
			charst.push(chars[j]);
		}
		for (var j = 0; j < charst.length; j++) {
			charst[j].innerHTML = arr[j];
		}
	}
	$(curid).removeClass("pwdkeyboardout").addClass("pwdkeyboard");
	document.querySelector(curid).addEventListener("webkitAnimationEnd", V.endshow, false);
	var ml = "-" + $("body").css("margin-left");
	var R = 0;
	var curh = parseInt($(curid).css("height"));
	if ((V.orientation() == 90) || (V.orientation() == -90)) {
		var bn = Math.max(window.innerHeight, document.documentElement.clientHeight);
		R = bn * V.proportion();
		if (R < curh) {
			R = curh;
		}
		$(curid).css("height", R);
		$("#purenumber_keyboard").css("height", R);
		$("#char_keyboard").css("height", R);
		$("#number_keyboard").css("height", R);
		$("#symble_keyboard").css("height", R);
	} else {
		var bn = Math.max(window.innerHeight, document.documentElement.clientHeight);
		R = bn * V.proportion();
		if (R < curh) {
			R = curh;
		}
		$(curid).css("height", R);
		$("#purenumber_keyboard").css("height", R);
		$("#char_keyboard").css("height", R);
		$("#number_keyboard").css("height", R);
		$("#symble_keyboard").css("height", R);
	}
	$(curid).css("margin-left", ml);
	$(curid).show();
};
keyBoard.prototype.hide = function(e) {
	var curid = "#" + this.settings.id;
	$(curid).removeClass("pwdkeyboard").addClass("pwdkeyboardout");
	return false;
};

function passGuard(options) {
	this.settings = {
		"id": "",
		"maxLength": 12,
		"regExp1": "[0-9]",
		"displayMode": 0,
		"rsaPublicKey": "",
		"mappurl": "",
		"randomKey": "",
		"enterEvent": "",
		"keyBoard": {},
		"mappingArray": []
	};
	this.bM = "";
	this.O = "";
	if (options != undefined) {
		this.settings = options;
	}
};
passGuard.aS = [];
passGuard.bS = [];
passGuard.mapArr = undefined;
passGuard.prototype.generate = function(id, keyBoard, or) {
	this.settings.keyBoard = keyBoard;
	this.settings.id = id;
	var obj = document.getElementById(id);
	passGuard.bS.push(obj);
	var pg = this;
	var flag = false;
	var interv = null;
	obj.onfocus = function(e) {
		this.blur();
		$(this).attr('placeholder', '');
		add = 1;
		if (reciveId != "" && reciveId != id) {
			pm = reciveId.substring(reciveId.length - 1, reciveId.length);
			if (eval("(" + 'passGuard' + pm + ")").O == "") {
				$("#" + reciveId).attr('placeholder', arrPlace[pm - 1]);
			}
			if (cs == 0) {
				var parrt2 = new RegExp(eval("(" + 'passGuard' + pm + ")").settings.regExp2);
				if (parrt2.test(eval("(" + 'passGuard' + pm + ")").bM)) {
					eval("(" + 'passGuard' + pm + ")").settings.callBack()
				} else {
					eval("(" + 'passGuard' + pm + ")").settings.errorCallBack()
				}
			}
			cs = 0;
		}
		cs = 0;
		if (or == 1) {
			$("#char_keyboard").hide();
			$("#number_keyboard").hide();
			$("#symble_keyboard").hide();
			$("#purenumber_keyboard").show();
		} else {
			$("#char_keyboard").show();
			$("#number_keyboard").hide();
			$("#symble_keyboard").hide();
			$("#purenumber_keyboard").hide();
		}
		if ((window.orientation == 90) || (window.orientation == -90)) {
			$("body").css({
				position: "relative",
				left: 0,
				top: "-" + $("#" + id).offset().top + "px",
				transition: "all 0.3s"
			})
		} else {
			$("body").css({
				height: ago + "px"
			});
			$("html").css({
				height: winHeight + "px"
			});
			var H1 = winHeight - $("#" + id).height() - $("#" + id).offset().top;
			var H = $("#testkbid").height();
			if (H1 < H) {
				$("body").css({
					position: "relative",
					left: 0,
					top: (H1 - H - 2) + "px",
					transition: "all 0.3s"
				})
			}
		};
		this.O = "";
		for (var int = 0; int < passGuard.aS.length; int++) {
			window.clearInterval(passGuard.aS[int]);
		}
		for (var int2 = 0; int2 < passGuard.bS.length; int2++) {
			passGuard.bS[int2].value = passGuard.bS[int2].value.replace(/I/, "");
		}
		passGuard.aS = [];
		if (passGuard.mapArr == undefined) {
			if (pg.settings.mappurl == undefined || pg.settings.mappurl == "") {
				alert("");
				return;
			}
			$.ajax({
				url: pg.settings.mappurl + "?" + get_time(),
				type: "GET",
				async: false,
				success: function(O) {
					pg.setMapping(O);
				}
			});
		}
		var input = this;
		interv = setInterval(function() {
			if (flag) {
				input.value = input.value.replace(/I/, "");
				flag = false;
			} else {
				input.value = input.value + "I";
				flag = true;
			}
		}, 500);
		passGuard.aS.push(interv);
		setTimeout(function() {
			keyBoard.aA = pg.aA;
			keyBoard.settings.pg = pg;
			keyBoard.settings.odd = 51;
			keyBoard.show();
			reciveId = id;
			e.preventDefault();
			return false;
		}, 0)
	}
};
passGuard.prototype.aA = function(event, key) {
	var bU = key ^ 51;
	var pg = this;
	var input = document.getElementById(pg.settings.id);
	input.value = input.value.replace(/I/, "");
	if (event == 1) {
		for (var int = 0; int < passGuard.aS.length; int++) {
			window.clearInterval(passGuard.aS[int]);
		}
	} else if (event == 2) {
		input.value = input.value.substr(0, input.value.length - 1);
		pg.O = pg.O.substr(0, pg.O.length - 1);
		pg.bM = pg.bM.substr(0, pg.bM.length - 1);
	} else if (event == 0) {
		var parrt = new RegExp(pg.settings.regExp1);
		var aE = String.fromCharCode(bU);
		var maxLen = pg.settings.maxLength;
		var len = input.value.length;
		if (len < maxLen) {
			if (parrt.test(aE)) {
				pg.bM += aE;
				pg.O += pg.aU(aE);
				if (pg.settings.displayMode == 1) {
					input.value += aE;
				} else {
					input.value += "*";
				}
			}
		}
	}
};
passGuard.prototype.setMapping = function(bE) {
	if (bE) {
		passGuard.mapArr = bE;
	}
};
passGuard.prototype.getValid = function() {
	var parrt = new RegExp(this.settings.regExp2);
	return parrt.test(this.bM) ? 0 : 1
};
passGuard.prototype.getOutput = function() {
	var crypt = new JSEncrypt();
	crypt.setPublicKey(this.settings.rsaPublicKey);
	var rsaStr = crypt.encrypt(this.O);
	var aesstr = dR($.trim(this.settings.randomKey), $.trim(rsaStr));
	passGuard.mapArr = undefined;
	this.bM = "";
	this.O = "";
	return aesstr;
};
passGuard.prototype.getLength = function() {
	return this.O.length;
};
passGuard.prototype.getHash = function() {
	return CryptoJS.MD5(this.O).toString();
};
passGuard.prototype.aU = function(key) {
	var keyCode = key.charCodeAt(0);
	var str = J(passGuard.mapArr);
	var aX = eval(str);
	return String.fromCharCode(aX[keyCode - 33]);
};
passGuard.prototype.setRandKey = function(bo) {
	try {
		if (bo) this.settings.randomKey = bo;
	} catch (e) {
		alert(e);
	}
};

function dR(bq, av) {
	var neiKey = [0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x1A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x3A, 0x3B, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x1A, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x3A, 0x3B];
	var fkey = "";
	var lx = "";
	for (var i = 0; i < bq.length; i++) {
		lx = String.fromCharCode(bq[i].charCodeAt(0) ^ neiKey[i]);
		fkey += lx;
	}
	fkey = fkey.substr(0, fkey.length - 16);
	var hexKey = CryptoJS.enc.Utf8.parse(fkey);
	var enStr = CryptoJS.AES.encrypt(av, hexKey, {
		mode: CryptoJS.mode.ECB,
		padding: CryptoJS.pad.Pkcs7
	});
	return enStr.toString();
}(function(window, document, Math) {
	var rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame ||
	function(callback) {
		window.setTimeout(callback, 1000 / 60);
	};
	var utils = (function() {
		var me = {};
		var _elementStyle = document.createElement('div').style;
		var _vendor = (function() {
			var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],
				transform, i = 0,
				l = vendors.length;
			for (; i < l; i++) {
				transform = vendors[i] + 'ransform';
				if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);
			}
			return false;
		})();

		function _prefixStyle(style) {
			if (_vendor === false) return false;
			if (_vendor === '') return style;
			return _vendor + style.charAt(0).toUpperCase() + style.substr(1);
		};
		me.getTime = Date.now ||
		function getTime() {
			return new Date().getTime();
		};
		me.extend = function(target, obj) {
			for (var i in obj) {
				target[i] = obj[i];
			}
		};
		me.addEvent = function(el, type, fn, capture) {
			el.addEventListener(type, fn, !!capture);
		};
		me.removeEvent = function(el, type, fn, capture) {
			el.removeEventListener(type, fn, !!capture);
		};
		me.prefixPointerEvent = function(pointerEvent) {
			return window.MSPointerEvent ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10) : pointerEvent;
		};
		me.momentum = function(current, start, time, lowerMargin, wrapperSize, deceleration) {
			var distance = current - start,
				speed = Math.abs(distance) / time,
				destination, duration;
			deceleration = deceleration === undefined ? 0.0006 : deceleration;
			destination = current + (speed * speed) / (2 * deceleration) * (distance < 0 ? -1 : 1);
			duration = speed / deceleration;
			if (destination < lowerMargin) {
				destination = wrapperSize ? lowerMargin - (wrapperSize / 2.5 * (speed / 8)) : lowerMargin;
				distance = Math.abs(destination - current);
				duration = distance / speed;
			} else if (destination > 0) {
				destination = wrapperSize ? wrapperSize / 2.5 * (speed / 8) : 0;
				distance = Math.abs(current) + destination;
				duration = distance / speed;
			}
			return {
				destination: Math.round(destination),
				duration: duration
			};
		};
		var _transform = _prefixStyle('transform');
		me.extend(me, {
			hasTransform: _transform !== false,
			hasPerspective: _prefixStyle('perspective') in _elementStyle,
			hasTouch: 'ontouchstart' in window,
			hasPointer: window.PointerEvent || window.MSPointerEvent,
			hasTransition: _prefixStyle('transition') in _elementStyle
		});
		me.isBadAndroid = /Android /.test(window.navigator.appVersion) && !(/Chrome\/\d/.test(window.navigator.appVersion));
		me.extend(me.style = {}, {
			transform: _transform,
			transitionTimingFunction: _prefixStyle('transitionTimingFunction'),
			transitionDuration: _prefixStyle('transitionDuration'),
			transitionDelay: _prefixStyle('transitionDelay'),
			transformOrigin: _prefixStyle('transformOrigin')
		});
		me.hasClass = function(e, c) {
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)");
			return re.test(e.className);
		};
		me.addClass = function(e, c) {
			if (me.hasClass(e, c)) {
				return;
			}
			var newclass = e.className.split(' ');
			newclass.push(c);
			e.className = newclass.join(' ');
		};
		me.removeClass = function(e, c) {
			if (!me.hasClass(e, c)) {
				return;
			}
			var re = new RegExp("(^|\\s)" + c + "(\\s|$)", 'g');
			e.className = e.className.replace(re, ' ');
		};
		me.offset = function(el) {
			var left = -el.offsetLeft,
				top = -el.offsetTop;
			while (el = el.offsetParent) {
				left -= el.offsetLeft;
				top -= el.offsetTop;
			}
			return {
				left: left,
				top: top
			};
		};
		me.preventDefaultException = function(el, exceptions) {
			for (var i in exceptions) {
				if (exceptions[i].test(el[i])) {
					return true;
				}
			}
			return false;
		};
		me.extend(me.eventType = {}, {
			touchstart: 1,
			touchmove: 1,
			touchend: 1,
			mousedown: 2,
			mousemove: 2,
			mouseup: 2,
			pointerdown: 3,
			pointermove: 3,
			pointerup: 3,
			MSPointerDown: 3,
			MSPointerMove: 3,
			MSPointerUp: 3
		});
		me.extend(me.ease = {}, {
			quadratic: {
				style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
				fn: function(k) {
					return k * (2 - k);
				}
			},
			circular: {
				style: 'cubic-bezier(0.1, 0.57, 0.1, 1)',
				fn: function(k) {
					return Math.sqrt(1 - (--k * k));
				}
			},
			back: {
				style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
				fn: function(k) {
					var b = 4;
					return (k = k - 1) * k * ((b + 1) * k + b) + 1;
				}
			},
			bounce: {
				style: '',
				fn: function(k) {
					if ((k /= 1) < (1 / 2.75)) {
						return 7.5625 * k * k;
					} else if (k < (2 / 2.75)) {
						return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
					} else if (k < (2.5 / 2.75)) {
						return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
					} else {
						return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
					}
				}
			},
			elastic: {
				style: '',
				fn: function(k) {
					var f = 0.22,
						e = 0.4;
					if (k === 0) {
						return 0;
					}
					if (k == 1) {
						return 1;
					}
					return (e * Math.pow(2, -10 * k) * Math.sin((k - f / 4) * (2 * Math.PI) / f) + 1);
				}
			}
		});
		me.tap = function(e, eventName) {
			var ev = document.createEvent('Event');
			ev.initEvent(eventName, true, true);
			ev.pageX = e.pageX;
			ev.pageY = e.pageY;
			e.target.dispatchEvent(ev);
		};
		me.click = function(e) {
			var target = e.target,
				ev;
			if (!(/(SELECT|INPUT|TEXTAREA)/i).test(target.tagName)) {
				ev = document.createEvent('MouseEvents');
				ev.initMouseEvent('click', true, true, e.view, 1, target.screenX, target.screenY, target.clientX, target.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);
				ev._constructed = true;
				target.dispatchEvent(ev);
			}
		};
		return me;
	})();

	function IScroll(el, options) {
		this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;
		this.scroller = this.wrapper.children[0];
		this.scrollerStyle = this.scroller.style;
		this.options = {
			resizeScrollbars: true,
			mouseWheelSpeed: 20,
			snapThreshold: 0.334,
			startX: 0,
			startY: 0,
			scrollY: true,
			directionLockThreshold: 5,
			momentum: true,
			bounce: true,
			bounceTime: 600,
			bounceEasing: '',
			preventDefault: true,
			preventDefaultException: {
				tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/
			},
			HWCompositing: true,
			useTransition: true,
			useTransform: true
		};
		for (var i in options) {
			this.options[i] = options[i];
		}
		this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';
		this.options.useTransition = utils.hasTransition && this.options.useTransition;
		this.options.useTransform = utils.hasTransform && this.options.useTransform;
		this.options.eventPassthrough = this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;
		this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;
		this.options.scrollY = this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;
		this.options.scrollX = this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;
		this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;
		this.options.directionLockThreshold = this.options.eventPassthrough ? 0 : this.options.directionLockThreshold;
		this.options.bounceEasing = typeof this.options.bounceEasing == 'string' ? utils.ease[this.options.bounceEasing] || utils.ease.circular : this.options.bounceEasing;
		this.options.resizePolling = this.options.resizePolling === undefined ? 60 : this.options.resizePolling;
		if (this.options.tap === true) {
			this.options.tap = 'tap';
		}
		if (this.options.shrinkScrollbars == 'scale') {
			this.options.useTransition = false;
		}
		this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;
		this.x = 0;
		this.y = 0;
		this.directionX = 0;
		this.directionY = 0;
		this._events = {};
		this._init();
		this.refresh();
		this.scrollTo(this.options.startX, this.options.startY);
		this.enable();
	};
	IScroll.prototype = {
		version: '5.1.3',
		_init: function() {
			this._initEvents();
			if (this.options.scrollbars || this.options.indicators) {
				this._initIndicators();
			}
			if (this.options.mouseWheel) {
				this._initWheel();
			}
			if (this.options.snap) {
				this._initSnap();
			}
			if (this.options.keyBindings) {
				this._initKeys();
			}
		},
		destroy: function() {
			this._initEvents(true);
			this._execEvent('destroy');
		},
		_transitionEnd: function(e) {
			if (e.target != this.scroller || !this.isInTransition) {
				return;
			}
			this._transitionTime();
			if (!this.resetPosition(this.options.bounceTime)) {
				this.isInTransition = false;
				this._execEvent('scrollEnd');
			}
		},
		_start: function(e) {
			if (utils.eventType[e.type] != 1) {
				if (e.button !== 0) {
					return;
				}
			}
			if (!this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated)) {
				return;
			}
			if (this.options.preventDefault && !utils.isBadAndroid && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}
			var point = e.touches ? e.touches[0] : e,
				pos;
			this.initiated = utils.eventType[e.type];
			this.moved = false;
			this.distX = 0;
			this.distY = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.directionLocked = 0;
			this._transitionTime();
			this.startTime = utils.getTime();
			if (this.options.useTransition && this.isInTransition) {
				this.isInTransition = false;
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this._execEvent('scrollEnd');
			} else if (!this.options.useTransition && this.isAnimating) {
				this.isAnimating = false;
				this._execEvent('scrollEnd');
			}
			this.startX = this.x;
			this.startY = this.y;
			this.absStartX = this.x;
			this.absStartY = this.y;
			this.pointX = point.pageX;
			this.pointY = point.pageY;
			this._execEvent('beforeScrollStart');
		},
		_move: function(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}
			if (this.options.preventDefault) {
				e.preventDefault();
			}
			var point = e.touches ? e.touches[0] : e,
				deltaX = point.pageX - this.pointX,
				deltaY = point.pageY - this.pointY,
				timestamp = utils.getTime(),
				newX, newY, absDistX, absDistY;
			this.pointX = point.pageX;
			this.pointY = point.pageY;
			this.distX += deltaX;
			this.distY += deltaY;
			absDistX = Math.abs(this.distX);
			absDistY = Math.abs(this.distY);
			if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {
				return;
			}
			if (!this.directionLocked && !this.options.freeScroll) {
				if (absDistX > absDistY + this.options.directionLockThreshold) {
					this.directionLocked = 'h';
				} else if (absDistY >= absDistX + this.options.directionLockThreshold) {
					this.directionLocked = 'v';
				} else {
					this.directionLocked = 'n';
				}
			}
			if (this.directionLocked == 'h') {
				if (this.options.eventPassthrough == 'vertical') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'horizontal') {
					this.initiated = false;
					return;
				}
				deltaY = 0;
			} else if (this.directionLocked == 'v') {
				if (this.options.eventPassthrough == 'horizontal') {
					e.preventDefault();
				} else if (this.options.eventPassthrough == 'vertical') {
					this.initiated = false;
					return;
				}
				deltaX = 0;
			}
			deltaX = this.hasHorizontalScroll ? deltaX : 0;
			deltaY = this.hasVerticalScroll ? deltaY : 0;
			newX = this.x + deltaX;
			newY = this.y + deltaY;
			if (newX > 0 || newX < this.maxScrollX) {
				newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;
			}
			if (newY > 0 || newY < this.maxScrollY) {
				newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;
			}
			this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
			this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;
			if (!this.moved) {
				this._execEvent('scrollStart');
			}
			this.moved = true;
			this._translate(newX, newY);
			if (timestamp - this.startTime > 300) {
				this.startTime = timestamp;
				this.startX = this.x;
				this.startY = this.y;
			}
		},
		_end: function(e) {
			if (!this.enabled || utils.eventType[e.type] !== this.initiated) {
				return;
			}
			if (this.options.preventDefault && !utils.preventDefaultException(e.target, this.options.preventDefaultException)) {
				e.preventDefault();
			}
			var point = e.changedTouches ? e.changedTouches[0] : e,
				momentumX, momentumY, duration = utils.getTime() - this.startTime,
				newX = Math.round(this.x),
				newY = Math.round(this.y),
				distanceX = Math.abs(newX - this.startX),
				distanceY = Math.abs(newY - this.startY),
				time = 0,
				easing = '';
			this.isInTransition = 0;
			this.initiated = 0;
			this.endTime = utils.getTime();
			if (this.resetPosition(this.options.bounceTime)) {
				return;
			}
			this.scrollTo(newX, newY);
			if (!this.moved) {
				if (this.options.tap) {
					utils.tap(e, this.options.tap);
				}
				if (this.options.click) {
					utils.click(e);
				}
				this._execEvent('scrollCancel');
				return;
			}
			if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {
				this._execEvent('flick');
				return;
			}
			if (this.options.momentum && duration < 300) {
				momentumX = this.hasHorizontalScroll ? utils.momentum(this.x, this.startX, duration, this.maxScrollX, this.options.bounce ? this.wrapperWidth : 0, this.options.deceleration) : {
					destination: newX,
					duration: 0
				};
				momentumY = this.hasVerticalScroll ? utils.momentum(this.y, this.startY, duration, this.maxScrollY, this.options.bounce ? this.wrapperHeight : 0, this.options.deceleration) : {
					destination: newY,
					duration: 0
				};
				newX = momentumX.destination;
				newY = momentumY.destination;
				time = Math.max(momentumX.duration, momentumY.duration);
				this.isInTransition = 1;
			}
			if (this.options.snap) {
				var snap = this._nearestSnap(newX, newY);
				this.currentPage = snap;
				time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(newX - snap.x), 1000), Math.min(Math.abs(newY - snap.y), 1000)), 300);
				newX = snap.x;
				newY = snap.y;
				this.directionX = 0;
				this.directionY = 0;
				easing = this.options.bounceEasing;
			}
			if (newX != this.x || newY != this.y) {
				if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {
					easing = utils.ease.quadratic;
				}
				this.scrollTo(newX, newY, time, easing);
				return;
			}
			this._execEvent('scrollEnd');
		},
		_resize: function() {
			var that = this;
			clearTimeout(this.resizeTimeout);
			this.resizeTimeout = setTimeout(function() {
				that.refresh();
			}, this.options.resizePolling);
		},
		resetPosition: function(time) {
			var x = this.x,
				y = this.y;
			time = time || 0;
			if (!this.hasHorizontalScroll || this.x > 0) {
				x = 0;
			} else if (this.x < this.maxScrollX) {
				x = this.maxScrollX;
			}
			if (!this.hasVerticalScroll || this.y > 0) {
				y = 0;
			} else if (this.y < this.maxScrollY) {
				y = this.maxScrollY;
			}
			if (x == this.x && y == this.y) {
				return false;
			}
			this.scrollTo(x, y, time, this.options.bounceEasing);
			return true;
		},
		disable: function() {
			this.enabled = false;
		},
		enable: function() {
			this.enabled = true;
		},
		refresh: function() {
			var rf = this.wrapper.offsetHeight;
			this.wrapperWidth = this.wrapper.clientWidth;
			this.wrapperHeight = this.wrapper.clientHeight;
			this.scrollerWidth = this.scroller.offsetWidth;
			this.scrollerHeight = this.scroller.offsetHeight;
			this.maxScrollX = this.wrapperWidth - this.scrollerWidth;
			this.maxScrollY = this.wrapperHeight - this.scrollerHeight;
			this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;
			this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;
			if (!this.hasHorizontalScroll) {
				this.maxScrollX = 0;
				this.scrollerWidth = this.wrapperWidth;
			}
			if (!this.hasVerticalScroll) {
				this.maxScrollY = 0;
				this.scrollerHeight = this.wrapperHeight;
			}
			this.endTime = 0;
			this.directionX = 0;
			this.directionY = 0;
			this.wrapperOffset = utils.offset(this.wrapper);
			this._execEvent('refresh');
			this.resetPosition();
		},
		on: function(type, fn) {
			if (!this._events[type]) {
				this._events[type] = [];
			}
			this._events[type].push(fn);
		},
		off: function(type, fn) {
			if (!this._events[type]) {
				return;
			}
			var index = this._events[type].indexOf(fn);
			if (index > -1) {
				this._events[type].splice(index, 1);
			}
		},
		_execEvent: function(type) {
			if (!this._events[type]) {
				return;
			}
			var i = 0,
				l = this._events[type].length;
			if (!l) {
				return;
			}
			for (; i < l; i++) {
				this._events[type][i].apply(this, [].slice.call(arguments, 1));
			}
		},
		scrollBy: function(x, y, time, easing) {
			x = this.x + x;
			y = this.y + y;
			time = time || 0;
			this.scrollTo(x, y, time, easing);
		},
		scrollTo: function(x, y, time, easing) {
			easing = easing || utils.ease.circular;
			this.isInTransition = this.options.useTransition && time > 0;
			if (!time || (this.options.useTransition && easing.style)) {
				this._transitionTimingFunction(easing.style);
				this._transitionTime(time);
				this._translate(x, y);
			} else {
				this._animate(x, y, time, easing.fn);
			}
		},
		scrollToElement: function(el, time, offsetX, offsetY, easing) {
			el = el.nodeType ? el : this.scroller.querySelector(el);
			if (!el) {
				return;
			}
			var pos = utils.offset(el);
			pos.left -= this.wrapperOffset.left;
			pos.top -= this.wrapperOffset.top;
			if (offsetX === true) {
				offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);
			}
			if (offsetY === true) {
				offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);
			}
			pos.left -= offsetX || 0;
			pos.top -= offsetY || 0;
			pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;
			pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;
			time = time === undefined || time === null || time === 'auto' ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top)) : time;
			this.scrollTo(pos.left, pos.top, time, easing);
		},
		_transitionTime: function(time) {
			time = time || 0;
			this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';
			if (!time && utils.isBadAndroid) {
				this.scrollerStyle[utils.style.transitionDuration] = '0.001s';
			}
			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTime(time);
				}
			}
		},
		_transitionTimingFunction: function(easing) {
			this.scrollerStyle[utils.style.transitionTimingFunction] = easing;
			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].transitionTimingFunction(easing);
				}
			}
		},
		_translate: function(x, y) {
			if (this.options.useTransform) {
				this.scrollerStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.translateZ;
			} else {
				x = Math.round(x);
				y = Math.round(y);
				this.scrollerStyle.left = x + 'px';
				this.scrollerStyle.top = y + 'px';
			}
			this.x = x;
			this.y = y;
			if (this.indicators) {
				for (var i = this.indicators.length; i--;) {
					this.indicators[i].updatePosition();
				}
			}
		},
		_initEvents: function(remove) {
			var eventType = remove ? utils.removeEvent : utils.addEvent,
				target = this.options.bindToWrapper ? this.wrapper : window;
			eventType(window, 'orientationchange', this);
			eventType(window, 'resize', this);
			if (this.options.click) {
				eventType(this.wrapper, 'click', this, true);
			}
			if (!this.options.disableMouse) {
				eventType(this.wrapper, 'mousedown', this);
				eventType(target, 'mousemove', this);
				eventType(target, 'mousecancel', this);
				eventType(target, 'mouseup', this);
			}
			if (utils.hasPointer && !this.options.disablePointer) {
				eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);
				eventType(target, utils.prefixPointerEvent('pointermove'), this);
				eventType(target, utils.prefixPointerEvent('pointercancel'), this);
				eventType(target, utils.prefixPointerEvent('pointerup'), this);
			}
			if (utils.hasTouch && !this.options.disableTouch) {
				eventType(this.wrapper, 'touchstart', this);
				eventType(target, 'touchmove', this);
				eventType(target, 'touchcancel', this);
				eventType(target, 'touchend', this);
			}
			eventType(this.scroller, 'transitionend', this);
			eventType(this.scroller, 'webkitTransitionEnd', this);
			eventType(this.scroller, 'oTransitionEnd', this);
			eventType(this.scroller, 'MSTransitionEnd', this);
		},
		getComputedPosition: function() {
			var matrix = window.getComputedStyle(this.scroller, null),
				x, y;
			if (this.options.useTransform) {
				matrix = matrix[utils.style.transform].split(')')[0].split(', ');
				x = +(matrix[12] || matrix[4]);
				y = +(matrix[13] || matrix[5]);
			} else {
				x = +matrix.left.replace(/[^-\d.]/g, '');
				y = +matrix.top.replace(/[^-\d.]/g, '');
			}
			return {
				x: x,
				y: y
			};
		},
		_initIndicators: function() {
			var interactive = this.options.interactiveScrollbars,
				customStyle = typeof this.options.scrollbars != 'string',
				indicators = [],
				indicator;
			var that = this;
			this.indicators = [];
			if (this.options.scrollbars) {
				if (this.options.scrollY) {
					indicator = {
						el: createDefaultScrollbar('v', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenX: false
					};
					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
				if (this.options.scrollX) {
					indicator = {
						el: createDefaultScrollbar('h', interactive, this.options.scrollbars),
						interactive: interactive,
						defaultScrollbars: true,
						customStyle: customStyle,
						resize: this.options.resizeScrollbars,
						shrink: this.options.shrinkScrollbars,
						fade: this.options.fadeScrollbars,
						listenY: false
					};
					this.wrapper.appendChild(indicator.el);
					indicators.push(indicator);
				}
			}
			if (this.options.indicators) {
				indicators = indicators.concat(this.options.indicators);
			}
			for (var i = indicators.length; i--;) {
				this.indicators.push(new Indicator(this, indicators[i]));
			}
			function _indicatorsMap(fn) {
				for (var i = that.indicators.length; i--;) {
					fn.call(that.indicators[i]);
				}
			};
			if (this.options.fadeScrollbars) {
				this.on('scrollEnd', function() {
					_indicatorsMap(function() {
						this.fade();
					});
				});
				this.on('scrollCancel', function() {
					_indicatorsMap(function() {
						this.fade();
					});
				});
				this.on('scrollStart', function() {
					_indicatorsMap(function() {
						this.fade(1);
					});
				});
				this.on('beforeScrollStart', function() {
					_indicatorsMap(function() {
						this.fade(1, true);
					});
				});
			}
			this.on('refresh', function() {
				_indicatorsMap(function() {
					this.refresh();
				});
			});
			this.on('destroy', function() {
				_indicatorsMap(function() {
					this.destroy();
				});
				delete this.indicators;
			});
		},
		_initWheel: function() {
			utils.addEvent(this.wrapper, 'wheel', this);
			utils.addEvent(this.wrapper, 'mousewheel', this);
			utils.addEvent(this.wrapper, 'DOMMouseScroll', this);
			this.on('destroy', function() {
				utils.removeEvent(this.wrapper, 'wheel', this);
				utils.removeEvent(this.wrapper, 'mousewheel', this);
				utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);
			});
		},
		_wheel: function(e) {
			if (!this.enabled) {
				return;
			}
			e.preventDefault();
			e.stopPropagation();
			var wheelDeltaX, wheelDeltaY, newX, newY, that = this;
			if (this.wheelTimeout === undefined) {
				that._execEvent('scrollStart');
			}
			clearTimeout(this.wheelTimeout);
			this.wheelTimeout = setTimeout(function() {
				that._execEvent('scrollEnd');
				that.wheelTimeout = undefined;
			}, 400);
			if ('deltaX' in e) {
				if (e.deltaMode === 1) {
					wheelDeltaX = -e.deltaX * this.options.mouseWheelSpeed;
					wheelDeltaY = -e.deltaY * this.options.mouseWheelSpeed;
				} else {
					wheelDeltaX = -e.deltaX;
					wheelDeltaY = -e.deltaY;
				}
			} else if ('wheelDeltaX' in e) {
				wheelDeltaX = e.wheelDeltaX / 120 * this.options.mouseWheelSpeed;
				wheelDeltaY = e.wheelDeltaY / 120 * this.options.mouseWheelSpeed;
			} else if ('wheelDelta' in e) {
				wheelDeltaX = wheelDeltaY = e.wheelDelta / 120 * this.options.mouseWheelSpeed;
			} else if ('detail' in e) {
				wheelDeltaX = wheelDeltaY = -e.detail / 3 * this.options.mouseWheelSpeed;
			} else {
				return;
			}
			wheelDeltaX *= this.options.invertWheelDirection;
			wheelDeltaY *= this.options.invertWheelDirection;
			if (!this.hasVerticalScroll) {
				wheelDeltaX = wheelDeltaY;
				wheelDeltaY = 0;
			}
			if (this.options.snap) {
				newX = this.currentPage.pageX;
				newY = this.currentPage.pageY;
				if (wheelDeltaX > 0) {
					newX--;
				} else if (wheelDeltaX < 0) {
					newX++;
				}
				if (wheelDeltaY > 0) {
					newY--;
				} else if (wheelDeltaY < 0) {
					newY++;
				}
				this.goToPage(newX, newY);
				return;
			}
			newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);
			newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);
			if (newX > 0) {
				newX = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
			}
			if (newY > 0) {
				newY = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
			}
			this.scrollTo(newX, newY, 0);
		},
		_initSnap: function() {
			this.currentPage = {};
			if (typeof this.options.snap == 'string') {
				this.options.snap = this.scroller.querySelectorAll(this.options.snap);
			}
			this.on('refresh', function() {
				var i = 0,
					l, m = 0,
					n, cx, cy, x = 0,
					y, stepX = this.options.snapStepX || this.wrapperWidth,
					stepY = this.options.snapStepY || this.wrapperHeight,
					el;
				this.pages = [];
				if (!this.wrapperWidth || !this.wrapperHeight || !this.scrollerWidth || !this.scrollerHeight) {
					return;
				}
				if (this.options.snap === true) {
					cx = Math.round(stepX / 2);
					cy = Math.round(stepY / 2);
					while (x > -this.scrollerWidth) {
						this.pages[i] = [];
						l = 0;
						y = 0;
						while (y > -this.scrollerHeight) {
							this.pages[i][l] = {
								x: Math.max(x, this.maxScrollX),
								y: Math.max(y, this.maxScrollY),
								width: stepX,
								height: stepY,
								cx: x - cx,
								cy: y - cy
							};
							y -= stepY;
							l++;
						}
						x -= stepX;
						i++;
					}
				} else {
					el = this.options.snap;
					l = el.length;
					n = -1;
					for (; i < l; i++) {
						if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {
							m = 0;
							n++;
						}
						if (!this.pages[m]) {
							this.pages[m] = [];
						}
						x = Math.max(-el[i].offsetLeft, this.maxScrollX);
						y = Math.max(-el[i].offsetTop, this.maxScrollY);
						cx = x - Math.round(el[i].offsetWidth / 2);
						cy = y - Math.round(el[i].offsetHeight / 2);
						this.pages[m][n] = {
							x: x,
							y: y,
							width: el[i].offsetWidth,
							height: el[i].offsetHeight,
							cx: cx,
							cy: cy
						};
						if (x > this.maxScrollX) {
							m++;
						}
					}
				}
				this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);
				if (this.options.snapThreshold % 1 === 0) {
					this.snapThresholdX = this.options.snapThreshold;
					this.snapThresholdY = this.options.snapThreshold;
				} else {
					this.snapThresholdX = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].width * this.options.snapThreshold);
					this.snapThresholdY = Math.round(this.pages[this.currentPage.pageX][this.currentPage.pageY].height * this.options.snapThreshold);
				}
			});
			this.on('flick', function() {
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.x - this.startX), 1000), Math.min(Math.abs(this.y - this.startY), 1000)), 300);
				this.goToPage(this.currentPage.pageX + this.directionX, this.currentPage.pageY + this.directionY, time);
			});
		},
		_nearestSnap: function(x, y) {
			if (!this.pages.length) {
				return {
					x: 0,
					y: 0,
					pageX: 0,
					pageY: 0
				};
			}
			var i = 0,
				l = this.pages.length,
				m = 0;
			if (Math.abs(x - this.absStartX) < this.snapThresholdX && Math.abs(y - this.absStartY) < this.snapThresholdY) {
				return this.currentPage;
			}
			if (x > 0) {
				x = 0;
			} else if (x < this.maxScrollX) {
				x = this.maxScrollX;
			}
			if (y > 0) {
				y = 0;
			} else if (y < this.maxScrollY) {
				y = this.maxScrollY;
			}
			for (; i < l; i++) {
				if (x >= this.pages[i][0].cx) {
					x = this.pages[i][0].x;
					break;
				}
			}
			l = this.pages[i].length;
			for (; m < l; m++) {
				if (y >= this.pages[0][m].cy) {
					y = this.pages[0][m].y;
					break;
				}
			}
			if (i == this.currentPage.pageX) {
				i += this.directionX;
				if (i < 0) {
					i = 0;
				} else if (i >= this.pages.length) {
					i = this.pages.length - 1;
				}
				x = this.pages[i][0].x;
			}
			if (m == this.currentPage.pageY) {
				m += this.directionY;
				if (m < 0) {
					m = 0;
				} else if (m >= this.pages[0].length) {
					m = this.pages[0].length - 1;
				}
				y = this.pages[0][m].y;
			}
			return {
				x: x,
				y: y,
				pageX: i,
				pageY: m
			};
		},
		goToPage: function(x, y, time, easing) {
			easing = easing || this.options.bounceEasing;
			if (x >= this.pages.length) {
				x = this.pages.length - 1;
			} else if (x < 0) {
				x = 0;
			}
			if (y >= this.pages[x].length) {
				y = this.pages[x].length - 1;
			} else if (y < 0) {
				y = 0;
			}
			var posX = this.pages[x][y].x,
				posY = this.pages[x][y].y;
			time = time === undefined ? this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(posX - this.x), 1000), Math.min(Math.abs(posY - this.y), 1000)), 300) : time;
			this.currentPage = {
				x: posX,
				y: posY,
				pageX: x,
				pageY: y
			};
			this.scrollTo(posX, posY, time, easing);
		},
		next: function(time, easing) {
			var x = this.currentPage.pageX,
				y = this.currentPage.pageY;
			x++;
			if (x >= this.pages.length && this.hasVerticalScroll) {
				x = 0;
				y++;
			}
			this.goToPage(x, y, time, easing);
		},
		prev: function(time, easing) {
			var x = this.currentPage.pageX,
				y = this.currentPage.pageY;
			x--;
			if (x < 0 && this.hasVerticalScroll) {
				x = 0;
				y--;
			}
			this.goToPage(x, y, time, easing);
		},
		_initKeys: function(e) {
			var keys = {
				pageUp: 33,
				pageDown: 34,
				end: 35,
				home: 36,
				left: 37,
				up: 38,
				right: 39,
				down: 40
			};
			var i;
			if (typeof this.options.keyBindings == 'object') {
				for (i in this.options.keyBindings) {
					if (typeof this.options.keyBindings[i] == 'string') {
						this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);
					}
				}
			} else {
				this.options.keyBindings = {};
			}
			for (i in keys) {
				this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];
			}
			utils.addEvent(window, 'keydown', this);
			this.on('destroy', function() {
				utils.removeEvent(window, 'keydown', this);
			});
		},
		_key: function(e) {
			if (!this.enabled) {
				return;
			}
			var snap = this.options.snap,
				newX = snap ? this.currentPage.pageX : this.x,
				newY = snap ? this.currentPage.pageY : this.y,
				now = utils.getTime(),
				prevTime = this.keyTime || 0,
				acceleration = 0.250,
				pos;
			if (this.options.useTransition && this.isInTransition) {
				pos = this.getComputedPosition();
				this._translate(Math.round(pos.x), Math.round(pos.y));
				this.isInTransition = false;
			}
			this.keyAcceleration = now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;
			switch (e.keyCode) {
			case this.options.keyBindings.pageUp:
				if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
					newX += snap ? 1 : this.wrapperWidth;
				} else {
					newY += snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.pageDown:
				if (this.hasHorizontalScroll && !this.hasVerticalScroll) {
					newX -= snap ? 1 : this.wrapperWidth;
				} else {
					newY -= snap ? 1 : this.wrapperHeight;
				}
				break;
			case this.options.keyBindings.end:
				newX = snap ? this.pages.length - 1 : this.maxScrollX;
				newY = snap ? this.pages[0].length - 1 : this.maxScrollY;
				break;
			case this.options.keyBindings.home:
				newX = 0;
				newY = 0;
				break;
			case this.options.keyBindings.left:
				newX += snap ? -1 : 5 + this.keyAcceleration >> 0;
				break;
			case this.options.keyBindings.up:
				newY += snap ? 1 : 5 + this.keyAcceleration >> 0;
				break;
			case this.options.keyBindings.right:
				newX -= snap ? -1 : 5 + this.keyAcceleration >> 0;
				break;
			case this.options.keyBindings.down:
				newY -= snap ? 1 : 5 + this.keyAcceleration >> 0;
				break;
			default:
				return;
			}
			if (snap) {
				this.goToPage(newX, newY);
				return;
			}
			if (newX > 0) {
				newX = 0;
				this.keyAcceleration = 0;
			} else if (newX < this.maxScrollX) {
				newX = this.maxScrollX;
				this.keyAcceleration = 0;
			}
			if (newY > 0) {
				newY = 0;
				this.keyAcceleration = 0;
			} else if (newY < this.maxScrollY) {
				newY = this.maxScrollY;
				this.keyAcceleration = 0;
			}
			this.scrollTo(newX, newY, 0);
			this.keyTime = now;
		},
		_animate: function(destX, destY, duration, easingFn) {
			var that = this,
				startX = this.x,
				startY = this.y,
				startTime = utils.getTime(),
				destTime = startTime + duration;

			function step() {
				var now = utils.getTime(),
					newX, newY, easing;
				if (now >= destTime) {
					that.isAnimating = false;
					that._translate(destX, destY);
					if (!that.resetPosition(that.options.bounceTime)) {
						that._execEvent('scrollEnd');
					}
					return;
				}
				now = (now - startTime) / duration;
				easing = easingFn(now);
				newX = (destX - startX) * easing + startX;
				newY = (destY - startY) * easing + startY;
				that._translate(newX, newY);
				if (that.isAnimating) {
					rAF(step);
				}
			};
			this.isAnimating = true;
			step();
		},
		handleEvent: function(e) {
			switch (e.type) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			case 'orientationchange':
			case 'resize':
				this._resize();
				break;
			case 'transitionend':
			case 'webkitTransitionEnd':
			case 'oTransitionEnd':
			case 'MSTransitionEnd':
				this._transitionEnd(e);
				break;
			case 'wheel':
			case 'DOMMouseScroll':
			case 'mousewheel':
				this._wheel(e);
				break;
			case 'keydown':
				this._key(e);
				break;
			case 'click':
				if (!e._constructed) {
					e.preventDefault();
					e.stopPropagation();
				}
				break;
			}
		}
	};

	function createDefaultScrollbar(direction, interactive, type) {
		var scrollbar = document.createElement('div'),
			indicator = document.createElement('div');
		if (type === true) {
			scrollbar.style.cssText = 'position:absolute;z-index:9999';
			indicator.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';
		}
		indicator.className = 'iScrollIndicator';
		if (direction == 'h') {
			if (type === true) {
				scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';
				indicator.style.height = '100%';
			}
			scrollbar.className = 'iScrollHorizontalScrollbar';
		} else {
			if (type === true) {
				scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';
				indicator.style.width = '100%';
			}
			scrollbar.className = 'iScrollVerticalScrollbar';
		}
		scrollbar.style.cssText += ';overflow:hidden';
		if (!interactive) {
			scrollbar.style.pointerEvents = 'none';
		}
		scrollbar.appendChild(indicator);
		return scrollbar;
	};

	function Indicator(scroller, options) {
		this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;
		this.wrapperStyle = this.wrapper.style;
		this.indicator = this.wrapper.children[0];
		this.indicatorStyle = this.indicator.style;
		this.scroller = scroller;
		this.options = {
			listenX: true,
			listenY: true,
			interactive: false,
			resize: true,
			defaultScrollbars: false,
			shrink: false,
			fade: false,
			speedRatioX: 0,
			speedRatioY: 0
		};
		for (var i in options) {
			this.options[i] = options[i];
		}
		this.sizeRatioX = 1;
		this.sizeRatioY = 1;
		this.maxPosX = 0;
		this.maxPosY = 0;
		if (this.options.interactive) {
			if (!this.options.disableTouch) {
				utils.addEvent(this.indicator, 'touchstart', this);
				utils.addEvent(window, 'touchend', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(this.indicator, 'mousedown', this);
				utils.addEvent(window, 'mouseup', this);
			}
		}
		if (this.options.fade) {
			this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;
			this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';
			this.wrapperStyle.opacity = '0';
		}
	};
	Indicator.prototype = {
		handleEvent: function(e) {
			switch (e.type) {
			case 'touchstart':
			case 'pointerdown':
			case 'MSPointerDown':
			case 'mousedown':
				this._start(e);
				break;
			case 'touchmove':
			case 'pointermove':
			case 'MSPointerMove':
			case 'mousemove':
				this._move(e);
				break;
			case 'touchend':
			case 'pointerup':
			case 'MSPointerUp':
			case 'mouseup':
			case 'touchcancel':
			case 'pointercancel':
			case 'MSPointerCancel':
			case 'mousecancel':
				this._end(e);
				break;
			}
		},
		destroy: function() {
			if (this.options.interactive) {
				utils.removeEvent(this.indicator, 'touchstart', this);
				utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);
				utils.removeEvent(this.indicator, 'mousedown', this);
				utils.removeEvent(window, 'touchmove', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
				utils.removeEvent(window, 'mousemove', this);
				utils.removeEvent(window, 'touchend', this);
				utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);
				utils.removeEvent(window, 'mouseup', this);
			}
			if (this.options.defaultScrollbars) {
				this.wrapper.parentNode.removeChild(this.wrapper);
			}
		},
		_start: function(e) {
			var point = e.touches ? e.touches[0] : e;
			e.preventDefault();
			e.stopPropagation();
			this.transitionTime();
			this.initiated = true;
			this.moved = false;
			this.lastPointX = point.pageX;
			this.lastPointY = point.pageY;
			this.startTime = utils.getTime();
			if (!this.options.disableTouch) {
				utils.addEvent(window, 'touchmove', this);
			}
			if (!this.options.disablePointer) {
				utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);
			}
			if (!this.options.disableMouse) {
				utils.addEvent(window, 'mousemove', this);
			}
			this.scroller._execEvent('beforeScrollStart');
		},
		_move: function(e) {
			var point = e.touches ? e.touches[0] : e,
				deltaX, deltaY, newX, newY, timestamp = utils.getTime();
			if (!this.moved) {
				this.scroller._execEvent('scrollStart');
			}
			this.moved = true;
			deltaX = point.pageX - this.lastPointX;
			this.lastPointX = point.pageX;
			deltaY = point.pageY - this.lastPointY;
			this.lastPointY = point.pageY;
			newX = this.x + deltaX;
			newY = this.y + deltaY;
			this._pos(newX, newY);
			e.preventDefault();
			e.stopPropagation();
		},
		_end: function(e) {
			if (!this.initiated) {
				return;
			}
			this.initiated = false;
			e.preventDefault();
			e.stopPropagation();
			utils.removeEvent(window, 'touchmove', this);
			utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);
			utils.removeEvent(window, 'mousemove', this);
			if (this.scroller.options.snap) {
				var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);
				var time = this.options.snapSpeed || Math.max(Math.max(Math.min(Math.abs(this.scroller.x - snap.x), 1000), Math.min(Math.abs(this.scroller.y - snap.y), 1000)), 300);
				if (this.scroller.x != snap.x || this.scroller.y != snap.y) {
					this.scroller.directionX = 0;
					this.scroller.directionY = 0;
					this.scroller.currentPage = snap;
					this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);
				}
			}
			if (this.moved) {
				this.scroller._execEvent('scrollEnd');
			}
		},
		transitionTime: function(time) {
			time = time || 0;
			this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';
			if (!time && utils.isBadAndroid) {
				this.indicatorStyle[utils.style.transitionDuration] = '0.001s';
			}
		},
		transitionTimingFunction: function(easing) {
			this.indicatorStyle[utils.style.transitionTimingFunction] = easing;
		},
		refresh: function() {
			this.transitionTime();
			if (this.options.listenX && !this.options.listenY) {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';
			} else if (this.options.listenY && !this.options.listenX) {
				this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';
			} else {
				this.indicatorStyle.display = this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';
			}
			if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {
				utils.addClass(this.wrapper, 'iScrollBothScrollbars');
				utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');
				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '8px';
					} else {
						this.wrapper.style.bottom = '8px';
					}
				}
			} else {
				utils.removeClass(this.wrapper, 'iScrollBothScrollbars');
				utils.addClass(this.wrapper, 'iScrollLoneScrollbar');
				if (this.options.defaultScrollbars && this.options.customStyle) {
					if (this.options.listenX) {
						this.wrapper.style.right = '2px';
					} else {
						this.wrapper.style.bottom = '2px';
					}
				}
			}
			var r = this.wrapper.offsetHeight;
			if (this.options.listenX) {
				this.wrapperWidth = this.wrapper.clientWidth;
				if (this.options.resize) {
					this.indicatorWidth = Math.max(Math.round(this.wrapperWidth * this.wrapperWidth / (this.scroller.scrollerWidth || this.wrapperWidth || 1)), 8);
					this.indicatorStyle.width = this.indicatorWidth + 'px';
				} else {
					this.indicatorWidth = this.indicator.clientWidth;
				}
				this.maxPosX = this.wrapperWidth - this.indicatorWidth;
				if (this.options.shrink == 'clip') {
					this.minBoundaryX = -this.indicatorWidth + 8;
					this.maxBoundaryX = this.wrapperWidth - 8;
				} else {
					this.minBoundaryX = 0;
					this.maxBoundaryX = this.maxPosX;
				}
				this.sizeRatioX = this.options.speedRatioX || (this.scroller.maxScrollX && (this.maxPosX / this.scroller.maxScrollX));
			}
			if (this.options.listenY) {
				this.wrapperHeight = this.wrapper.clientHeight;
				if (this.options.resize) {
					this.indicatorHeight = Math.max(Math.round(this.wrapperHeight * this.wrapperHeight / (this.scroller.scrollerHeight || this.wrapperHeight || 1)), 8);
					this.indicatorStyle.height = this.indicatorHeight + 'px';
				} else {
					this.indicatorHeight = this.indicator.clientHeight;
				}
				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				if (this.options.shrink == 'clip') {
					this.minBoundaryY = -this.indicatorHeight + 8;
					this.maxBoundaryY = this.wrapperHeight - 8;
				} else {
					this.minBoundaryY = 0;
					this.maxBoundaryY = this.maxPosY;
				}
				this.maxPosY = this.wrapperHeight - this.indicatorHeight;
				this.sizeRatioY = this.options.speedRatioY || (this.scroller.maxScrollY && (this.maxPosY / this.scroller.maxScrollY));
			}
			this.updatePosition();
		},
		updatePosition: function() {
			var x = this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x) || 0,
				y = this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y) || 0;
			if (!this.options.ignoreBoundaries) {
				if (x < this.minBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth + x, 8);
						this.indicatorStyle.width = this.width + 'px';
					}
					x = this.minBoundaryX;
				} else if (x > this.maxBoundaryX) {
					if (this.options.shrink == 'scale') {
						this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);
						this.indicatorStyle.width = this.width + 'px';
						x = this.maxPosX + this.indicatorWidth - this.width;
					} else {
						x = this.maxBoundaryX;
					}
				} else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {
					this.width = this.indicatorWidth;
					this.indicatorStyle.width = this.width + 'px';
				}
				if (y < this.minBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight + y * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
					}
					y = this.minBoundaryY;
				} else if (y > this.maxBoundaryY) {
					if (this.options.shrink == 'scale') {
						this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);
						this.indicatorStyle.height = this.height + 'px';
						y = this.maxPosY + this.indicatorHeight - this.height;
					} else {
						y = this.maxBoundaryY;
					}
				} else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {
					this.height = this.indicatorHeight;
					this.indicatorStyle.height = this.height + 'px';
				}
			}
			this.x = x;
			this.y = y;
			if (this.scroller.options.useTransform) {
				this.indicatorStyle[utils.style.transform] = 'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;
			} else {
				this.indicatorStyle.left = x + 'px';
				this.indicatorStyle.top = y + 'px';
			}
		},
		_pos: function(x, y) {
			if (x < 0) {
				x = 0;
			} else if (x > this.maxPosX) {
				x = this.maxPosX;
			}
			if (y < 0) {
				y = 0;
			} else if (y > this.maxPosY) {
				y = this.maxPosY;
			}
			x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;
			y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;
			this.scroller.scrollTo(x, y);
		},
		fade: function(val, hold) {
			if (hold && !this.visible) {
				return;
			}
			clearTimeout(this.fadeTimeout);
			this.fadeTimeout = null;
			var time = val ? 250 : 500,
				delay = val ? 0 : 300;
			val = val ? '1' : '0';
			this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';
			this.fadeTimeout = setTimeout((function(val) {
				this.wrapperStyle.opacity = val;
				this.visible = +val;
			}).bind(this, val), delay);
		}
	};
	IScroll.utils = utils;
	if (typeof module != 'undefined' && module.exports) {
		module.exports = IScroll;
	} else {
		window.IScroll = IScroll;
	}
})(window, document, Math);;
(function(root, factory) {
	if (typeof exports === "object") {
		module.exports = exports = factory();
	} else if (typeof define === "function" && define.amd) {
		define([], factory);
	} else {
		root.CryptoJS = factory();
	}
}(this, function() {
	var CryptoJS = CryptoJS || (function(Math, undefined) {
		var C = {};
		var C_lib = C.lib = {};
		var Base = C_lib.Base = (function() {
			function F() {};
			return {
				extend: function(overrides) {
					F.prototype = this;
					var subtype = new F();
					if (overrides) {
						subtype.mixIn(overrides);
					}
					if (!subtype.hasOwnProperty('init')) {
						subtype.init = function() {
							subtype.$super.init.apply(this, arguments);
						};
					}
					subtype.init.prototype = subtype;
					subtype.$super = this;
					return subtype;
				},
				create: function() {
					var instance = this.extend();
					instance.init.apply(instance, arguments);
					return instance;
				},
				init: function() {},
				mixIn: function(properties) {
					for (var propertyName in properties) {
						if (properties.hasOwnProperty(propertyName)) {
							this[propertyName] = properties[propertyName];
						}
					}
					if (properties.hasOwnProperty('toString')) {
						this.toString = properties.toString;
					}
				},
				clone: function() {
					return this.init.prototype.extend(this);
				}
			};
		}());
		var WordArray = C_lib.WordArray = Base.extend({
			init: function(words, sigBytes) {
				words = this.words = words || [];
				if (sigBytes != undefined) {
					this.sigBytes = sigBytes;
				} else {
					this.sigBytes = words.length * 4;
				}
			},
			toString: function(encoder) {
				return (encoder || Hex).stringify(this);
			},
			concat: function(wordArray) {
				var thisWords = this.words;
				var thatWords = wordArray.words;
				var thisSigBytes = this.sigBytes;
				var thatSigBytes = wordArray.sigBytes;
				this.clamp();
				if (thisSigBytes % 4) {
					for (var i = 0; i < thatSigBytes; i++) {
						var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
						thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
					}
				} else {
					for (var i = 0; i < thatSigBytes; i += 4) {
						thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
					}
				}
				this.sigBytes += thatSigBytes;
				return this;
			},
			clamp: function() {
				var words = this.words;
				var sigBytes = this.sigBytes;
				words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
				words.length = Math.ceil(sigBytes / 4);
			},
			clone: function() {
				var clone = Base.clone.call(this);
				clone.words = this.words.slice(0);
				return clone;
			},
			random: function(nBytes) {
				var words = [];
				var r = (function(m_w) {
					var m_w = m_w;
					var m_z = 0x3ade68b1;
					var mask = 0xffffffff;
					return function() {
						m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
						m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
						var result = ((m_z << 0x10) + m_w) & mask;
						result /= 0x100000000;
						result += 0.5;
						return result * (Math.random() > .5 ? 1 : -1);
					}
				});
				for (var i = 0, rcache; i < nBytes; i += 4) {
					var _r = r((rcache || Math.random()) * 0x100000000);
					rcache = _r() * 0x3ade67b7;
					words.push((_r() * 0x100000000) | 0);
				}
				return new WordArray.init(words, nBytes);
			}
		});
		var C_enc = C.enc = {};
		var Hex = C_enc.Hex = {
			stringify: function(wordArray) {
				var words = wordArray.words;
				var sigBytes = wordArray.sigBytes;
				var hexChars = [];
				for (var i = 0; i < sigBytes; i++) {
					var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
					hexChars.push((bite >>> 4).toString(16));
					hexChars.push((bite & 0x0f).toString(16));
				}
				return hexChars.join('');
			},
			parse: function(hexStr) {
				var hexStrLength = hexStr.length;
				var words = [];
				for (var i = 0; i < hexStrLength; i += 2) {
					words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
				}
				return new WordArray.init(words, hexStrLength / 2);
			}
		};
		var Latin1 = C_enc.Latin1 = {
			stringify: function(wordArray) {
				var words = wordArray.words;
				var sigBytes = wordArray.sigBytes;
				var latin1Chars = [];
				for (var i = 0; i < sigBytes; i++) {
					var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
					latin1Chars.push(String.fromCharCode(bite));
				}
				return latin1Chars.join('');
			},
			parse: function(latin1Str) {
				var latin1StrLength = latin1Str.length;
				var words = [];
				for (var i = 0; i < latin1StrLength; i++) {
					words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
				}
				return new WordArray.init(words, latin1StrLength);
			}
		};
		var Utf8 = C_enc.Utf8 = {
			stringify: function(wordArray) {
				try {
					return decodeURIComponent(escape(Latin1.stringify(wordArray)));
				} catch (e) {
					throw new Error('Malformed UTF-8 data');
				}
			},
			parse: function(utf8Str) {
				return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			}
		};
		var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			reset: function() {
				this._data = new WordArray.init();
				this._nDataBytes = 0;
			},
			_append: function(data) {
				if (typeof data == 'string') {
					data = Utf8.parse(data);
				}
				this._data.concat(data);
				this._nDataBytes += data.sigBytes;
			},
			_process: function(doFlush) {
				var data = this._data;
				var dataWords = data.words;
				var dataSigBytes = data.sigBytes;
				var blockSize = this.blockSize;
				var blockSizeBytes = blockSize * 4;
				var nBlocksReady = dataSigBytes / blockSizeBytes;
				if (doFlush) {
					nBlocksReady = Math.ceil(nBlocksReady);
				} else {
					nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
				}
				var nWordsReady = nBlocksReady * blockSize;
				var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
				if (nWordsReady) {
					for (var offset = 0; offset < nWordsReady; offset += blockSize) {
						this._doProcessBlock(dataWords, offset);
					}
					var processedWords = dataWords.splice(0, nWordsReady);
					data.sigBytes -= nBytesReady;
				}
				return new WordArray.init(processedWords, nBytesReady);
			},
			clone: function() {
				var clone = Base.clone.call(this);
				clone._data = this._data.clone();
				return clone;
			},
			_minBufferSize: 0
		});
		var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
			cfg: Base.extend(),
			init: function(cfg) {
				this.cfg = this.cfg.extend(cfg);
				this.reset();
			},
			reset: function() {
				BufferedBlockAlgorithm.reset.call(this);
				this._doReset();
			},
			update: function(messageUpdate) {
				this._append(messageUpdate);
				this._process();
				return this;
			},
			finalize: function(messageUpdate) {
				if (messageUpdate) {
					this._append(messageUpdate);
				}
				var hash = this._doFinalize();
				return hash;
			},
			blockSize: 512 / 32,
			_createHelper: function(hasher) {
				return function(message, cfg) {
					return new hasher.init(cfg).finalize(message);
				};
			},
			_createHmacHelper: function(hasher) {
				return function(message, key) {
					return new C_algo.HMAC.init(hasher, key).finalize(message);
				};
			}
		});
		var C_algo = C.algo = {};
		return C;
	}(Math));
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var C_enc = C.enc;
		var Base64 = C_enc.Base64 = {
			stringify: function(wordArray) {
				var words = wordArray.words;
				var sigBytes = wordArray.sigBytes;
				var map = this._map;
				wordArray.clamp();
				var base64Chars = [];
				for (var i = 0; i < sigBytes; i += 3) {
					var byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
					var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
					var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;
					var triplet = (byte1 << 16) | (byte2 << 8) | byte3;
					for (var j = 0;
					(j < 4) && (i + j * 0.75 < sigBytes); j++) {
						base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
					}
				}
				var paddingChar = map.charAt(64);
				if (paddingChar) {
					while (base64Chars.length % 4) {
						base64Chars.push(paddingChar);
					}
				}
				return base64Chars.join('');
			},
			parse: function(base64Str) {
				var base64StrLength = base64Str.length;
				var map = this._map;
				var paddingChar = map.charAt(64);
				if (paddingChar) {
					var paddingIndex = base64Str.indexOf(paddingChar);
					if (paddingIndex != -1) {
						base64StrLength = paddingIndex;
					}
				}
				var words = [];
				var nBytes = 0;
				for (var i = 0; i < base64StrLength; i++) {
					if (i % 4) {
						var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);
						var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);
						words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
						nBytes++;
					}
				}
				return WordArray.create(words, nBytes);
			},
			_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
		};
	}());
	(function(Math) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var Hasher = C_lib.Hasher;
		var C_algo = C.algo;
		var T = [];
		(function() {
			for (var i = 0; i < 64; i++) {
				T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
			}
		}());
		var MD5 = C_algo.MD5 = Hasher.extend({
			_doReset: function() {
				this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
			},
			_doProcessBlock: function(M, offset) {
				for (var i = 0; i < 16; i++) {
					var offset_i = offset + i;
					var M_offset_i = M[offset_i];
					M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
				}
				var H = this._hash.words;
				var M_offset_0 = M[offset + 0];
				var M_offset_1 = M[offset + 1];
				var M_offset_2 = M[offset + 2];
				var M_offset_3 = M[offset + 3];
				var M_offset_4 = M[offset + 4];
				var M_offset_5 = M[offset + 5];
				var M_offset_6 = M[offset + 6];
				var M_offset_7 = M[offset + 7];
				var M_offset_8 = M[offset + 8];
				var M_offset_9 = M[offset + 9];
				var M_offset_10 = M[offset + 10];
				var M_offset_11 = M[offset + 11];
				var M_offset_12 = M[offset + 12];
				var M_offset_13 = M[offset + 13];
				var M_offset_14 = M[offset + 14];
				var M_offset_15 = M[offset + 15];
				var a = H[0];
				var b = H[1];
				var c = H[2];
				var d = H[3];
				a = FF(a, b, c, d, M_offset_0, 7, T[0]);
				d = FF(d, a, b, c, M_offset_1, 12, T[1]);
				c = FF(c, d, a, b, M_offset_2, 17, T[2]);
				b = FF(b, c, d, a, M_offset_3, 22, T[3]);
				a = FF(a, b, c, d, M_offset_4, 7, T[4]);
				d = FF(d, a, b, c, M_offset_5, 12, T[5]);
				c = FF(c, d, a, b, M_offset_6, 17, T[6]);
				b = FF(b, c, d, a, M_offset_7, 22, T[7]);
				a = FF(a, b, c, d, M_offset_8, 7, T[8]);
				d = FF(d, a, b, c, M_offset_9, 12, T[9]);
				c = FF(c, d, a, b, M_offset_10, 17, T[10]);
				b = FF(b, c, d, a, M_offset_11, 22, T[11]);
				a = FF(a, b, c, d, M_offset_12, 7, T[12]);
				d = FF(d, a, b, c, M_offset_13, 12, T[13]);
				c = FF(c, d, a, b, M_offset_14, 17, T[14]);
				b = FF(b, c, d, a, M_offset_15, 22, T[15]);
				a = GG(a, b, c, d, M_offset_1, 5, T[16]);
				d = GG(d, a, b, c, M_offset_6, 9, T[17]);
				c = GG(c, d, a, b, M_offset_11, 14, T[18]);
				b = GG(b, c, d, a, M_offset_0, 20, T[19]);
				a = GG(a, b, c, d, M_offset_5, 5, T[20]);
				d = GG(d, a, b, c, M_offset_10, 9, T[21]);
				c = GG(c, d, a, b, M_offset_15, 14, T[22]);
				b = GG(b, c, d, a, M_offset_4, 20, T[23]);
				a = GG(a, b, c, d, M_offset_9, 5, T[24]);
				d = GG(d, a, b, c, M_offset_14, 9, T[25]);
				c = GG(c, d, a, b, M_offset_3, 14, T[26]);
				b = GG(b, c, d, a, M_offset_8, 20, T[27]);
				a = GG(a, b, c, d, M_offset_13, 5, T[28]);
				d = GG(d, a, b, c, M_offset_2, 9, T[29]);
				c = GG(c, d, a, b, M_offset_7, 14, T[30]);
				b = GG(b, c, d, a, M_offset_12, 20, T[31]);
				a = HH(a, b, c, d, M_offset_5, 4, T[32]);
				d = HH(d, a, b, c, M_offset_8, 11, T[33]);
				c = HH(c, d, a, b, M_offset_11, 16, T[34]);
				b = HH(b, c, d, a, M_offset_14, 23, T[35]);
				a = HH(a, b, c, d, M_offset_1, 4, T[36]);
				d = HH(d, a, b, c, M_offset_4, 11, T[37]);
				c = HH(c, d, a, b, M_offset_7, 16, T[38]);
				b = HH(b, c, d, a, M_offset_10, 23, T[39]);
				a = HH(a, b, c, d, M_offset_13, 4, T[40]);
				d = HH(d, a, b, c, M_offset_0, 11, T[41]);
				c = HH(c, d, a, b, M_offset_3, 16, T[42]);
				b = HH(b, c, d, a, M_offset_6, 23, T[43]);
				a = HH(a, b, c, d, M_offset_9, 4, T[44]);
				d = HH(d, a, b, c, M_offset_12, 11, T[45]);
				c = HH(c, d, a, b, M_offset_15, 16, T[46]);
				b = HH(b, c, d, a, M_offset_2, 23, T[47]);
				a = II(a, b, c, d, M_offset_0, 6, T[48]);
				d = II(d, a, b, c, M_offset_7, 10, T[49]);
				c = II(c, d, a, b, M_offset_14, 15, T[50]);
				b = II(b, c, d, a, M_offset_5, 21, T[51]);
				a = II(a, b, c, d, M_offset_12, 6, T[52]);
				d = II(d, a, b, c, M_offset_3, 10, T[53]);
				c = II(c, d, a, b, M_offset_10, 15, T[54]);
				b = II(b, c, d, a, M_offset_1, 21, T[55]);
				a = II(a, b, c, d, M_offset_8, 6, T[56]);
				d = II(d, a, b, c, M_offset_15, 10, T[57]);
				c = II(c, d, a, b, M_offset_6, 15, T[58]);
				b = II(b, c, d, a, M_offset_13, 21, T[59]);
				a = II(a, b, c, d, M_offset_4, 6, T[60]);
				d = II(d, a, b, c, M_offset_11, 10, T[61]);
				c = II(c, d, a, b, M_offset_2, 15, T[62]);
				b = II(b, c, d, a, M_offset_9, 21, T[63]);
				H[0] = (H[0] + a) | 0;
				H[1] = (H[1] + b) | 0;
				H[2] = (H[2] + c) | 0;
				H[3] = (H[3] + d) | 0;
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
				var nBitsTotalL = nBitsTotal;
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = ((((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00));
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00));
				data.sigBytes = (dataWords.length + 1) * 4;
				this._process();
				var hash = this._hash;
				var H = hash.words;
				for (var i = 0; i < 4; i++) {
					var H_i = H[i];
					H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
				}
				return hash;
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				clone._hash = this._hash.clone();
				return clone;
			}
		});

		function FF(a, b, c, d, x, s, t) {
			var n = a + ((b & c) | (~b & d)) + x + t;
			return ((n << s) | (n >>> (32 - s))) + b;
		};

		function GG(a, b, c, d, x, s, t) {
			var n = a + ((b & d) | (c & ~d)) + x + t;
			return ((n << s) | (n >>> (32 - s))) + b;
		};

		function HH(a, b, c, d, x, s, t) {
			var n = a + (b ^ c ^ d) + x + t;
			return ((n << s) | (n >>> (32 - s))) + b;
		};

		function II(a, b, c, d, x, s, t) {
			var n = a + (c ^ (b | ~d)) + x + t;
			return ((n << s) | (n >>> (32 - s))) + b;
		};
		C.MD5 = Hasher._createHelper(MD5);
		C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var Hasher = C_lib.Hasher;
		var C_algo = C.algo;
		var W = [];
		var SHA1 = C_algo.SHA1 = Hasher.extend({
			_doReset: function() {
				this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
			},
			_doProcessBlock: function(M, offset) {
				var H = this._hash.words;
				var a = H[0];
				var b = H[1];
				var c = H[2];
				var d = H[3];
				var e = H[4];
				for (var i = 0; i < 80; i++) {
					if (i < 16) {
						W[i] = M[offset + i] | 0;
					} else {
						var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
						W[i] = (n << 1) | (n >>> 31);
					}
					var t = ((a << 5) | (a >>> 27)) + e + W[i];
					if (i < 20) {
						t += ((b & c) | (~b & d)) + 0x5a827999;
					} else if (i < 40) {
						t += (b ^ c ^ d) + 0x6ed9eba1;
					} else if (i < 60) {
						t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
					} else {
						t += (b ^ c ^ d) - 0x359d3e2a;
					}
					e = d;
					d = c;
					c = (b << 30) | (b >>> 2);
					b = a;
					a = t;
				}
				H[0] = (H[0] + a) | 0;
				H[1] = (H[1] + b) | 0;
				H[2] = (H[2] + c) | 0;
				H[3] = (H[3] + d) | 0;
				H[4] = (H[4] + e) | 0;
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				data.sigBytes = dataWords.length * 4;
				this._process();
				return this._hash;
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				clone._hash = this._hash.clone();
				return clone;
			}
		});
		C.SHA1 = Hasher._createHelper(SHA1);
		C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());
	(function(Math) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var Hasher = C_lib.Hasher;
		var C_algo = C.algo;
		var H = [];
		var K = [];
		(function() {
			function isPrime(n) {
				var sqrtN = Math.sqrt(n);
				for (var factor = 2; factor <= sqrtN; factor++) {
					if (!(n % factor)) {
						return false;
					}
				}
				return true;
			};

			function getFractionalBits(n) {
				return ((n - (n | 0)) * 0x100000000) | 0;
			};
			var n = 2;
			var nPrime = 0;
			while (nPrime < 64) {
				if (isPrime(n)) {
					if (nPrime < 8) {
						H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
					}
					K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
					nPrime++;
				}
				n++;
			}
		}());
		var W = [];
		var SHA256 = C_algo.SHA256 = Hasher.extend({
			_doReset: function() {
				this._hash = new WordArray.init(H.slice(0));
			},
			_doProcessBlock: function(M, offset) {
				var H = this._hash.words;
				var a = H[0];
				var b = H[1];
				var c = H[2];
				var d = H[3];
				var e = H[4];
				var f = H[5];
				var g = H[6];
				var h = H[7];
				for (var i = 0; i < 64; i++) {
					if (i < 16) {
						W[i] = M[offset + i] | 0;
					} else {
						var gamma0x = W[i - 15];
						var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^ ((gamma0x << 14) | (gamma0x >>> 18)) ^ (gamma0x >>> 3);
						var gamma1x = W[i - 2];
						var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^ ((gamma1x << 13) | (gamma1x >>> 19)) ^ (gamma1x >>> 10);
						W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
					}
					var ch = (e & f) ^ (~e & g);
					var maj = (a & b) ^ (a & c) ^ (b & c);
					var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
					var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));
					var t1 = h + sigma1 + ch + K[i] + W[i];
					var t2 = sigma0 + maj;
					h = g;
					g = f;
					f = e;
					e = (d + t1) | 0;
					d = c;
					c = b;
					b = a;
					a = (t1 + t2) | 0;
				}
				H[0] = (H[0] + a) | 0;
				H[1] = (H[1] + b) | 0;
				H[2] = (H[2] + c) | 0;
				H[3] = (H[3] + d) | 0;
				H[4] = (H[4] + e) | 0;
				H[5] = (H[5] + f) | 0;
				H[6] = (H[6] + g) | 0;
				H[7] = (H[7] + h) | 0;
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
				data.sigBytes = dataWords.length * 4;
				this._process();
				return this._hash;
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				clone._hash = this._hash.clone();
				return clone;
			}
		});
		C.SHA256 = Hasher._createHelper(SHA256);
		C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var C_enc = C.enc;
		var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
			stringify: function(wordArray) {
				var words = wordArray.words;
				var sigBytes = wordArray.sigBytes;
				var utf16Chars = [];
				for (var i = 0; i < sigBytes; i += 2) {
					var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
					utf16Chars.push(String.fromCharCode(codePoint));
				}
				return utf16Chars.join('');
			},
			parse: function(utf16Str) {
				var utf16StrLength = utf16Str.length;
				var words = [];
				for (var i = 0; i < utf16StrLength; i++) {
					words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
				}
				return WordArray.create(words, utf16StrLength * 2);
			}
		};
		C_enc.Utf16LE = {
			stringify: function(wordArray) {
				var words = wordArray.words;
				var sigBytes = wordArray.sigBytes;
				var utf16Chars = [];
				for (var i = 0; i < sigBytes; i += 2) {
					var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
					utf16Chars.push(String.fromCharCode(codePoint));
				}
				return utf16Chars.join('');
			},
			parse: function(utf16Str) {
				var utf16StrLength = utf16Str.length;
				var words = [];
				for (var i = 0; i < utf16StrLength; i++) {
					words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
				}
				return WordArray.create(words, utf16StrLength * 2);
			}
		};

		function swapEndian(word) {
			return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
		}
	}());
	(function() {
		if (typeof ArrayBuffer != 'function') {
			return;
		}
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var superInit = WordArray.init;
		var subInit = WordArray.init = function(typedArray) {
				if (typedArray instanceof ArrayBuffer) {
					typedArray = new Uint8Array(typedArray);
				}
				if (typedArray instanceof Int8Array || (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
					typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
				}
				if (typedArray instanceof Uint8Array) {
					var typedArrayByteLength = typedArray.byteLength;
					var words = [];
					for (var i = 0; i < typedArrayByteLength; i++) {
						words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
					}
					superInit.call(this, words, typedArrayByteLength);
				} else {
					superInit.apply(this, arguments);
				}
			};
		subInit.prototype = WordArray;
	}());
	(function(Math) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var Hasher = C_lib.Hasher;
		var C_algo = C.algo;
		var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
		var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
		var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
		var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
		var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
		var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
		var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
			_doReset: function() {
				this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
			},
			_doProcessBlock: function(M, offset) {
				for (var i = 0; i < 16; i++) {
					var offset_i = offset + i;
					var M_offset_i = M[offset_i];
					M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
				}
				var H = this._hash.words;
				var hl = _hl.words;
				var hr = _hr.words;
				var zl = _zl.words;
				var zr = _zr.words;
				var sl = _sl.words;
				var sr = _sr.words;
				var al, bl, cl, dl, el;
				var ar, br, cr, dr, er;
				ar = al = H[0];
				br = bl = H[1];
				cr = cl = H[2];
				dr = dl = H[3];
				er = el = H[4];
				var t;
				for (var i = 0; i < 80; i += 1) {
					t = (al + M[offset + zl[i]]) | 0;
					if (i < 16) {
						t += f1(bl, cl, dl) + hl[0];
					} else if (i < 32) {
						t += f2(bl, cl, dl) + hl[1];
					} else if (i < 48) {
						t += f3(bl, cl, dl) + hl[2];
					} else if (i < 64) {
						t += f4(bl, cl, dl) + hl[3];
					} else {
						t += f5(bl, cl, dl) + hl[4];
					}
					t = t | 0;
					t = rotl(t, sl[i]);
					t = (t + el) | 0;
					al = el;
					el = dl;
					dl = rotl(cl, 10);
					cl = bl;
					bl = t;
					t = (ar + M[offset + zr[i]]) | 0;
					if (i < 16) {
						t += f5(br, cr, dr) + hr[0];
					} else if (i < 32) {
						t += f4(br, cr, dr) + hr[1];
					} else if (i < 48) {
						t += f3(br, cr, dr) + hr[2];
					} else if (i < 64) {
						t += f2(br, cr, dr) + hr[3];
					} else {
						t += f1(br, cr, dr) + hr[4];
					}
					t = t | 0;
					t = rotl(t, sr[i]);
					t = (t + er) | 0;
					ar = er;
					er = dr;
					dr = rotl(cr, 10);
					cr = br;
					br = t;
				}
				t = (H[1] + cl + dr) | 0;
				H[1] = (H[2] + dl + er) | 0;
				H[2] = (H[3] + el + ar) | 0;
				H[3] = (H[4] + al + br) | 0;
				H[4] = (H[0] + bl + cr) | 0;
				H[0] = t;
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
				data.sigBytes = (dataWords.length + 1) * 4;
				this._process();
				var hash = this._hash;
				var H = hash.words;
				for (var i = 0; i < 5; i++) {
					var H_i = H[i];
					H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
				}
				return hash;
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				clone._hash = this._hash.clone();
				return clone;
			}
		});

		function f1(x, y, z) {
			return ((x) ^ (y) ^ (z));
		};

		function f2(x, y, z) {
			return (((x) & (y)) | ((~x) & (z)));
		};

		function f3(x, y, z) {
			return (((x) | (~ (y))) ^ (z));
		};

		function f4(x, y, z) {
			return (((x) & (z)) | ((y) & (~ (z))));
		};

		function f5(x, y, z) {
			return ((x) ^ ((y) | (~ (z))));
		};

		function rotl(x, n) {
			return (x << n) | (x >>> (32 - n));
		};
		C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
		C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Base = C_lib.Base;
		var C_enc = C.enc;
		var Utf8 = C_enc.Utf8;
		var C_algo = C.algo;
		var HMAC = C_algo.HMAC = Base.extend({
			init: function(hasher, key) {
				hasher = this._hasher = new hasher.init();
				if (typeof key == 'string') {
					key = Utf8.parse(key);
				}
				var hasherBlockSize = hasher.blockSize;
				var hasherBlockSizeBytes = hasherBlockSize * 4;
				if (key.sigBytes > hasherBlockSizeBytes) {
					key = hasher.finalize(key);
				}
				key.clamp();
				var oKey = this._oKey = key.clone();
				var iKey = this._iKey = key.clone();
				var oKeyWords = oKey.words;
				var iKeyWords = iKey.words;
				for (var i = 0; i < hasherBlockSize; i++) {
					oKeyWords[i] ^= 0x5c5c5c5c;
					iKeyWords[i] ^= 0x36363636;
				}
				oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
				this.reset();
			},
			reset: function() {
				var hasher = this._hasher;
				hasher.reset();
				hasher.update(this._iKey);
			},
			update: function(messageUpdate) {
				this._hasher.update(messageUpdate);
				return this;
			},
			finalize: function(messageUpdate) {
				var hasher = this._hasher;
				var innerHash = hasher.finalize(messageUpdate);
				hasher.reset();
				var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
				return hmac;
			}
		});
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Base = C_lib.Base;
		var WordArray = C_lib.WordArray;
		var C_algo = C.algo;
		var SHA1 = C_algo.SHA1;
		var HMAC = C_algo.HMAC;
		var PBKDF2 = C_algo.PBKDF2 = Base.extend({
			cfg: Base.extend({
				keySize: 128 / 32,
				hasher: SHA1,
				iterations: 1
			}),
			init: function(cfg) {
				this.cfg = this.cfg.extend(cfg);
			},
			compute: function(password, salt) {
				var cfg = this.cfg;
				var hmac = HMAC.create(cfg.hasher, password);
				var derivedKey = WordArray.create();
				var blockIndex = WordArray.create([0x00000001]);
				var derivedKeyWords = derivedKey.words;
				var blockIndexWords = blockIndex.words;
				var keySize = cfg.keySize;
				var iterations = cfg.iterations;
				while (derivedKeyWords.length < keySize) {
					var block = hmac.update(salt).finalize(blockIndex);
					hmac.reset();
					var blockWords = block.words;
					var blockWordsLength = blockWords.length;
					var intermediate = block;
					for (var i = 1; i < iterations; i++) {
						intermediate = hmac.finalize(intermediate);
						hmac.reset();
						var intermediateWords = intermediate.words;
						for (var j = 0; j < blockWordsLength; j++) {
							blockWords[j] ^= intermediateWords[j];
						}
					}
					derivedKey.concat(block);
					blockIndexWords[0]++;
				}
				derivedKey.sigBytes = keySize * 4;
				return derivedKey;
			}
		});
		C.PBKDF2 = function(password, salt, cfg) {
			return PBKDF2.create(cfg).compute(password, salt);
		};
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Base = C_lib.Base;
		var WordArray = C_lib.WordArray;
		var C_algo = C.algo;
		var MD5 = C_algo.MD5;
		var EvpKDF = C_algo.EvpKDF = Base.extend({
			cfg: Base.extend({
				keySize: 128 / 32,
				hasher: MD5,
				iterations: 1
			}),
			init: function(cfg) {
				this.cfg = this.cfg.extend(cfg);
			},
			compute: function(password, salt) {
				var cfg = this.cfg;
				var hasher = cfg.hasher.create();
				var derivedKey = WordArray.create();
				var derivedKeyWords = derivedKey.words;
				var keySize = cfg.keySize;
				var iterations = cfg.iterations;
				while (derivedKeyWords.length < keySize) {
					if (block) {
						hasher.update(block);
					}
					var block = hasher.update(password).finalize(salt);
					hasher.reset();
					for (var i = 1; i < iterations; i++) {
						block = hasher.finalize(block);
						hasher.reset();
					}
					derivedKey.concat(block);
				}
				derivedKey.sigBytes = keySize * 4;
				return derivedKey;
			}
		});
		C.EvpKDF = function(password, salt, cfg) {
			return EvpKDF.create(cfg).compute(password, salt);
		};
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var C_algo = C.algo;
		var SHA256 = C_algo.SHA256;
		var SHA224 = C_algo.SHA224 = SHA256.extend({
			_doReset: function() {
				this._hash = new WordArray.init([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
			},
			_doFinalize: function() {
				var hash = SHA256._doFinalize.call(this);
				hash.sigBytes -= 4;
				return hash;
			}
		});
		C.SHA224 = SHA256._createHelper(SHA224);
		C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());
	(function(undefined) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Base = C_lib.Base;
		var X32WordArray = C_lib.WordArray;
		var C_x64 = C.x64 = {};
		var X64Word = C_x64.Word = Base.extend({
			init: function(high, low) {
				this.high = high;
				this.low = low;
			}
		});
		var X64WordArray = C_x64.WordArray = Base.extend({
			init: function(words, sigBytes) {
				words = this.words = words || [];
				if (sigBytes != undefined) {
					this.sigBytes = sigBytes;
				} else {
					this.sigBytes = words.length * 8;
				}
			},
			toX32: function() {
				var x64Words = this.words;
				var x64WordsLength = x64Words.length;
				var x32Words = [];
				for (var i = 0; i < x64WordsLength; i++) {
					var x64Word = x64Words[i];
					x32Words.push(x64Word.high);
					x32Words.push(x64Word.low);
				}
				return X32WordArray.create(x32Words, this.sigBytes);
			},
			clone: function() {
				var clone = Base.clone.call(this);
				var words = clone.words = this.words.slice(0);
				var wordsLength = words.length;
				for (var i = 0; i < wordsLength; i++) {
					words[i] = words[i].clone();
				}
				return clone;
			}
		});
	}());
	(function(Math) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var Hasher = C_lib.Hasher;
		var C_x64 = C.x64;
		var X64Word = C_x64.Word;
		var C_algo = C.algo;
		var RHO_OFFSETS = [];
		var PI_INDEXES = [];
		var ROUND_CONSTANTS = [];
		(function() {
			var x = 1,
				y = 0;
			for (var t = 0; t < 24; t++) {
				RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;
				var newX = y % 5;
				var newY = (2 * x + 3 * y) % 5;
				x = newX;
				y = newY;
			}
			for (var x = 0; x < 5; x++) {
				for (var y = 0; y < 5; y++) {
					PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
				}
			}
			var LFSR = 0x01;
			for (var i = 0; i < 24; i++) {
				var roundConstantMsw = 0;
				var roundConstantLsw = 0;
				for (var j = 0; j < 7; j++) {
					if (LFSR & 0x01) {
						var bitPosition = (1 << j) - 1;
						if (bitPosition < 32) {
							roundConstantLsw ^= 1 << bitPosition;
						} else {
							roundConstantMsw ^= 1 << (bitPosition - 32);
						}
					}
					if (LFSR & 0x80) {
						LFSR = (LFSR << 1) ^ 0x71;
					} else {
						LFSR <<= 1;
					}
				}
				ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
			}
		}());
		var T = [];
		(function() {
			for (var i = 0; i < 25; i++) {
				T[i] = X64Word.create();
			}
		}());
		var SHA3 = C_algo.SHA3 = Hasher.extend({
			cfg: Hasher.cfg.extend({
				outputLength: 512
			}),
			_doReset: function() {
				var state = this._state = [];
				for (var i = 0; i < 25; i++) {
					state[i] = new X64Word.init();
				}
				this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
			},
			_doProcessBlock: function(M, offset) {
				var state = this._state;
				var nBlockSizeLanes = this.blockSize / 2;
				for (var i = 0; i < nBlockSizeLanes; i++) {
					var M2i = M[offset + 2 * i];
					var M2i1 = M[offset + 2 * i + 1];
					M2i = ((((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00));
					M2i1 = ((((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00));
					var lane = state[i];
					lane.high ^= M2i1;
					lane.low ^= M2i;
				}
				for (var round = 0; round < 24; round++) {
					for (var x = 0; x < 5; x++) {
						var tMsw = 0,
							tLsw = 0;
						for (var y = 0; y < 5; y++) {
							var lane = state[x + 5 * y];
							tMsw ^= lane.high;
							tLsw ^= lane.low;
						}
						var Tx = T[x];
						Tx.high = tMsw;
						Tx.low = tLsw;
					}
					for (var x = 0; x < 5; x++) {
						var Tx4 = T[(x + 4) % 5];
						var Tx1 = T[(x + 1) % 5];
						var Tx1Msw = Tx1.high;
						var Tx1Lsw = Tx1.low;
						var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
						var tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
						for (var y = 0; y < 5; y++) {
							var lane = state[x + 5 * y];
							lane.high ^= tMsw;
							lane.low ^= tLsw;
						}
					}
					for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
						var lane = state[laneIndex];
						var laneMsw = lane.high;
						var laneLsw = lane.low;
						var rhoOffset = RHO_OFFSETS[laneIndex];
						if (rhoOffset < 32) {
							var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
							var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
						} else {
							var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
							var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
						}
						var TPiLane = T[PI_INDEXES[laneIndex]];
						TPiLane.high = tMsw;
						TPiLane.low = tLsw;
					}
					var T0 = T[0];
					var state0 = state[0];
					T0.high = state0.high;
					T0.low = state0.low;
					for (var x = 0; x < 5; x++) {
						for (var y = 0; y < 5; y++) {
							var laneIndex = x + 5 * y;
							var lane = state[laneIndex];
							var TLane = T[laneIndex];
							var Tx1Lane = T[((x + 1) % 5) + 5 * y];
							var Tx2Lane = T[((x + 2) % 5) + 5 * y];
							lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
							lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
						}
					}
					var lane = state[0];
					var roundConstant = ROUND_CONSTANTS[round];
					lane.high ^= roundConstant.high;
					lane.low ^= roundConstant.low;;
				}
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				var blockSizeBits = this.blockSize * 32;
				dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
				dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
				data.sigBytes = dataWords.length * 4;
				this._process();
				var state = this._state;
				var outputLengthBytes = this.cfg.outputLength / 8;
				var outputLengthLanes = outputLengthBytes / 8;
				var hashWords = [];
				for (var i = 0; i < outputLengthLanes; i++) {
					var lane = state[i];
					var laneMsw = lane.high;
					var laneLsw = lane.low;
					laneMsw = ((((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00));
					laneLsw = ((((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00));
					hashWords.push(laneLsw);
					hashWords.push(laneMsw);
				}
				return new WordArray.init(hashWords, outputLengthBytes);
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				var state = clone._state = this._state.slice(0);
				for (var i = 0; i < 25; i++) {
					state[i] = state[i].clone();
				}
				return clone;
			}
		});
		C.SHA3 = Hasher._createHelper(SHA3);
		C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Hasher = C_lib.Hasher;
		var C_x64 = C.x64;
		var X64Word = C_x64.Word;
		var X64WordArray = C_x64.WordArray;
		var C_algo = C.algo;

		function X64Word_create() {
			return X64Word.create.apply(X64Word, arguments);
		};
		var K = [X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd), X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc), X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019), X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118), X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe), X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2), X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1), X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694), X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3), X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65), X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483), X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5), X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210), X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4), X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725), X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70), X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926), X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df), X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8), X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b), X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001), X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30), X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910), X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8), X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53), X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8), X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb), X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3), X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60), X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec), X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9), X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b), X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207), X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178), X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6), X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b), X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493), X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c), X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a), X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)];
		var W = [];
		(function() {
			for (var i = 0; i < 80; i++) {
				W[i] = X64Word_create();
			}
		}());
		var SHA512 = C_algo.SHA512 = Hasher.extend({
			_doReset: function() {
				this._hash = new X64WordArray.init([new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b), new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1), new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f), new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)]);
			},
			_doProcessBlock: function(M, offset) {
				var H = this._hash.words;
				var H0 = H[0];
				var H1 = H[1];
				var H2 = H[2];
				var H3 = H[3];
				var H4 = H[4];
				var H5 = H[5];
				var H6 = H[6];
				var H7 = H[7];
				var H0h = H0.high;
				var H0l = H0.low;
				var H1h = H1.high;
				var H1l = H1.low;
				var H2h = H2.high;
				var H2l = H2.low;
				var H3h = H3.high;
				var H3l = H3.low;
				var H4h = H4.high;
				var H4l = H4.low;
				var H5h = H5.high;
				var H5l = H5.low;
				var H6h = H6.high;
				var H6l = H6.low;
				var H7h = H7.high;
				var H7l = H7.low;
				var ah = H0h;
				var al = H0l;
				var bh = H1h;
				var bl = H1l;
				var ch = H2h;
				var cl = H2l;
				var dh = H3h;
				var dl = H3l;
				var eh = H4h;
				var el = H4l;
				var fh = H5h;
				var fl = H5l;
				var gh = H6h;
				var gl = H6l;
				var hh = H7h;
				var hl = H7l;
				for (var i = 0; i < 80; i++) {
					var Wi = W[i];
					if (i < 16) {
						var Wih = Wi.high = M[offset + i * 2] | 0;
						var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
					} else {
						var gamma0x = W[i - 15];
						var gamma0xh = gamma0x.high;
						var gamma0xl = gamma0x.low;
						var gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
						var gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));
						var gamma1x = W[i - 2];
						var gamma1xh = gamma1x.high;
						var gamma1xl = gamma1x.low;
						var gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
						var gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));
						var Wi7 = W[i - 7];
						var Wi7h = Wi7.high;
						var Wi7l = Wi7.low;
						var Wi16 = W[i - 16];
						var Wi16h = Wi16.high;
						var Wi16l = Wi16.low;
						var Wil = gamma0l + Wi7l;
						var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
						var Wil = Wil + gamma1l;
						var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
						var Wil = Wil + Wi16l;
						var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);
						Wi.high = Wih;
						Wi.low = Wil;
					}
					var chh = (eh & fh) ^ (~eh & gh);
					var chl = (el & fl) ^ (~el & gl);
					var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
					var majl = (al & bl) ^ (al & cl) ^ (bl & cl);
					var sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
					var sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
					var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
					var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));
					var Ki = K[i];
					var Kih = Ki.high;
					var Kil = Ki.low;
					var t1l = hl + sigma1l;
					var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
					var t1l = t1l + chl;
					var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
					var t1l = t1l + Kil;
					var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
					var t1l = t1l + Wil;
					var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);
					var t2l = sigma0l + majl;
					var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);
					hh = gh;
					hl = gl;
					gh = fh;
					gl = fl;
					fh = eh;
					fl = el;
					el = (dl + t1l) | 0;
					eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
					dh = ch;
					dl = cl;
					ch = bh;
					cl = bl;
					bh = ah;
					bl = al;
					al = (t1l + t2l) | 0;
					ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
				}
				H0l = H0.low = (H0l + al);
				H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
				H1l = H1.low = (H1l + bl);
				H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
				H2l = H2.low = (H2l + cl);
				H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
				H3l = H3.low = (H3l + dl);
				H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
				H4l = H4.low = (H4l + el);
				H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
				H5l = H5.low = (H5l + fl);
				H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
				H6l = H6.low = (H6l + gl);
				H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
				H7l = H7.low = (H7l + hl);
				H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
			},
			_doFinalize: function() {
				var data = this._data;
				var dataWords = data.words;
				var nBitsTotal = this._nDataBytes * 8;
				var nBitsLeft = data.sigBytes * 8;
				dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
				dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
				dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
				data.sigBytes = dataWords.length * 4;
				this._process();
				var hash = this._hash.toX32();
				return hash;
			},
			clone: function() {
				var clone = Hasher.clone.call(this);
				clone._hash = this._hash.clone();
				return clone;
			},
			blockSize: 1024 / 32
		});
		C.SHA512 = Hasher._createHelper(SHA512);
		C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());
	(function() {
		var C = CryptoJS;
		var C_x64 = C.x64;
		var X64Word = C_x64.Word;
		var X64WordArray = C_x64.WordArray;
		var C_algo = C.algo;
		var SHA512 = C_algo.SHA512;
		var SHA384 = C_algo.SHA384 = SHA512.extend({
			_doReset: function() {
				this._hash = new X64WordArray.init([new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507), new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939), new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511), new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)]);
			},
			_doFinalize: function() {
				var hash = SHA512._doFinalize.call(this);
				hash.sigBytes -= 16;
				return hash;
			}
		});
		C.SHA384 = SHA512._createHelper(SHA384);
		C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());
	CryptoJS.lib.Cipher || (function(undefined) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var Base = C_lib.Base;
		var WordArray = C_lib.WordArray;
		var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
		var C_enc = C.enc;
		var Utf8 = C_enc.Utf8;
		var Base64 = C_enc.Base64;
		var C_algo = C.algo;
		var EvpKDF = C_algo.EvpKDF;
		var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
			cfg: Base.extend(),
			createEncryptor: function(key, cfg) {
				return this.create(this._ENC_XFORM_MODE, key, cfg);
			},
			createDecryptor: function(key, cfg) {
				return this.create(this._DEC_XFORM_MODE, key, cfg);
			},
			init: function(xformMode, key, cfg) {
				this.cfg = this.cfg.extend(cfg);
				this._xformMode = xformMode;
				this._key = key;
				this.reset();
			},
			reset: function() {
				BufferedBlockAlgorithm.reset.call(this);
				this._doReset();
			},
			process: function(dataUpdate) {
				this._append(dataUpdate);
				return this._process();
			},
			finalize: function(dataUpdate) {
				if (dataUpdate) {
					this._append(dataUpdate);
				}
				var finalProcessedData = this._doFinalize();
				return finalProcessedData;
			},
			keySize: 128 / 32,
			ivSize: 128 / 32,
			_ENC_XFORM_MODE: 1,
			_DEC_XFORM_MODE: 2,
			_createHelper: (function() {
				function selectCipherStrategy(key) {
					if (typeof key == 'string') {
						return PasswordBasedCipher;
					} else {
						return SerializableCipher;
					}
				};
				return function(cipher) {
					return {
						encrypt: function(message, key, cfg) {
							return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
						},
						decrypt: function(ciphertext, key, cfg) {
							return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
						}
					};
				};
			}())
		});
		var StreamCipher = C_lib.StreamCipher = Cipher.extend({
			_doFinalize: function() {
				var finalProcessedBlocks = this._process(!!'flush');
				return finalProcessedBlocks;
			},
			blockSize: 1
		});
		var C_mode = C.mode = {};
		var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
			createEncryptor: function(cipher, iv) {
				return this.Encryptor.create(cipher, iv);
			},
			createDecryptor: function(cipher, iv) {
				return this.Decryptor.create(cipher, iv);
			},
			init: function(cipher, iv) {
				this._cipher = cipher;
				this._iv = iv;
			}
		});
		var CBC = C_mode.CBC = (function() {
			var CBC = BlockCipherMode.extend();
			CBC.Encryptor = CBC.extend({
				processBlock: function(words, offset) {
					var cipher = this._cipher;
					var blockSize = cipher.blockSize;
					xorBlock.call(this, words, offset, blockSize);
					cipher.encryptBlock(words, offset);
					this._prevBlock = words.slice(offset, offset + blockSize);
				}
			});
			CBC.Decryptor = CBC.extend({
				processBlock: function(words, offset) {
					var cipher = this._cipher;
					var blockSize = cipher.blockSize;
					var thisBlock = words.slice(offset, offset + blockSize);
					cipher.decryptBlock(words, offset);
					xorBlock.call(this, words, offset, blockSize);
					this._prevBlock = thisBlock;
				}
			});

			function xorBlock(words, offset, blockSize) {
				var iv = this._iv;
				if (iv) {
					var block = iv;
					this._iv = undefined;
				} else {
					var block = this._prevBlock;
				}
				for (var i = 0; i < blockSize; i++) {
					words[offset + i] ^= block[i];
				}
			};
			return CBC;
		}());
		var C_pad = C.pad = {};
		var Pkcs7 = C_pad.Pkcs7 = {
			pad: function(data, blockSize) {
				var blockSizeBytes = blockSize * 4;
				var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
				var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;
				var paddingWords = [];
				for (var i = 0; i < nPaddingBytes; i += 4) {
					paddingWords.push(paddingWord);
				}
				var padding = WordArray.create(paddingWords, nPaddingBytes);
				data.concat(padding);
			},
			unpad: function(data) {
				var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
				data.sigBytes -= nPaddingBytes;
			}
		};
		var BlockCipher = C_lib.BlockCipher = Cipher.extend({
			cfg: Cipher.cfg.extend({
				mode: CBC,
				padding: Pkcs7
			}),
			reset: function() {
				Cipher.reset.call(this);
				var cfg = this.cfg;
				var iv = cfg.iv;
				var mode = cfg.mode;
				if (this._xformMode == this._ENC_XFORM_MODE) {
					var modeCreator = mode.createEncryptor;
				} else {
					var modeCreator = mode.createDecryptor;
					this._minBufferSize = 1;
				}
				this._mode = modeCreator.call(mode, this, iv && iv.words);
			},
			_doProcessBlock: function(words, offset) {
				this._mode.processBlock(words, offset);
			},
			_doFinalize: function() {
				var padding = this.cfg.padding;
				if (this._xformMode == this._ENC_XFORM_MODE) {
					padding.pad(this._data, this.blockSize);
					var finalProcessedBlocks = this._process(!!'flush');
				} else {
					var finalProcessedBlocks = this._process(!!'flush');
					padding.unpad(finalProcessedBlocks);
				}
				return finalProcessedBlocks;
			},
			blockSize: 128 / 32
		});
		var CipherParams = C_lib.CipherParams = Base.extend({
			init: function(cipherParams) {
				this.mixIn(cipherParams);
			},
			toString: function(formatter) {
				return (formatter || this.formatter).stringify(this);
			}
		});
		var C_format = C.format = {};
		var OpenSSLFormatter = C_format.OpenSSL = {
			stringify: function(cipherParams) {
				var ciphertext = cipherParams.ciphertext;
				var salt = cipherParams.salt;
				if (salt) {
					var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
				} else {
					var wordArray = ciphertext;
				}
				return wordArray.toString(Base64);
			},
			parse: function(openSSLStr) {
				var ciphertext = Base64.parse(openSSLStr);
				var ciphertextWords = ciphertext.words;
				if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
					var salt = WordArray.create(ciphertextWords.slice(2, 4));
					ciphertextWords.splice(0, 4);
					ciphertext.sigBytes -= 16;
				}
				return CipherParams.create({
					ciphertext: ciphertext,
					salt: salt
				});
			}
		};
		var SerializableCipher = C_lib.SerializableCipher = Base.extend({
			cfg: Base.extend({
				format: OpenSSLFormatter
			}),
			encrypt: function(cipher, message, key, cfg) {
				cfg = this.cfg.extend(cfg);
				var encryptor = cipher.createEncryptor(key, cfg);
				var ciphertext = encryptor.finalize(message);
				var cipherCfg = encryptor.cfg;
				return CipherParams.create({
					ciphertext: ciphertext,
					key: key,
					iv: cipherCfg.iv,
					algorithm: cipher,
					mode: cipherCfg.mode,
					padding: cipherCfg.padding,
					blockSize: cipher.blockSize,
					formatter: cfg.format
				});
			},
			decrypt: function(cipher, ciphertext, key, cfg) {
				cfg = this.cfg.extend(cfg);
				ciphertext = this._parse(ciphertext, cfg.format);
				var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
				return plaintext;
			},
			_parse: function(ciphertext, format) {
				if (typeof ciphertext == 'string') {
					return format.parse(ciphertext, this);
				} else {
					return ciphertext;
				}
			}
		});
		var C_kdf = C.kdf = {};
		var OpenSSLKdf = C_kdf.OpenSSL = {
			execute: function(password, keySize, ivSize, salt) {
				if (!salt) {
					salt = WordArray.random(64 / 8);
				}
				var key = EvpKDF.create({
					keySize: keySize + ivSize
				}).compute(password, salt);
				var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
				key.sigBytes = keySize * 4;
				return CipherParams.create({
					key: key,
					iv: iv,
					salt: salt
				});
			}
		};
		var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
			cfg: SerializableCipher.cfg.extend({
				kdf: OpenSSLKdf
			}),
			encrypt: function(cipher, message, password, cfg) {
				cfg = this.cfg.extend(cfg);
				var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
				cfg.iv = derivedParams.iv;
				var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
				ciphertext.mixIn(derivedParams);
				return ciphertext;
			},
			decrypt: function(cipher, ciphertext, password, cfg) {
				cfg = this.cfg.extend(cfg);
				ciphertext = this._parse(ciphertext, cfg.format);
				var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
				cfg.iv = derivedParams.iv;
				var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
				return plaintext;
			}
		});
	}());
	CryptoJS.mode.CFB = (function() {
		var CFB = CryptoJS.lib.BlockCipherMode.extend();
		CFB.Encryptor = CFB.extend({
			processBlock: function(words, offset) {
				var cipher = this._cipher;
				var blockSize = cipher.blockSize;
				generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
				this._prevBlock = words.slice(offset, offset + blockSize);
			}
		});
		CFB.Decryptor = CFB.extend({
			processBlock: function(words, offset) {
				var cipher = this._cipher;
				var blockSize = cipher.blockSize;
				var thisBlock = words.slice(offset, offset + blockSize);
				generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
				this._prevBlock = thisBlock;
			}
		});

		function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
			var iv = this._iv;
			if (iv) {
				var keystream = iv.slice(0);
				this._iv = undefined;
			} else {
				var keystream = this._prevBlock;
			}
			cipher.encryptBlock(keystream, 0);
			for (var i = 0; i < blockSize; i++) {
				words[offset + i] ^= keystream[i];
			}
		};
		return CFB;
	}());
	CryptoJS.mode.ECB = (function() {
		var ECB = CryptoJS.lib.BlockCipherMode.extend();
		ECB.Encryptor = ECB.extend({
			processBlock: function(words, offset) {
				this._cipher.encryptBlock(words, offset);
			}
		});
		ECB.Decryptor = ECB.extend({
			processBlock: function(words, offset) {
				this._cipher.decryptBlock(words, offset);
			}
		});
		return ECB;
	}());
	CryptoJS.pad.AnsiX923 = {
		pad: function(data, blockSize) {
			var dataSigBytes = data.sigBytes;
			var blockSizeBytes = blockSize * 4;
			var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
			var lastBytePos = dataSigBytes + nPaddingBytes - 1;
			data.clamp();
			data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
			data.sigBytes += nPaddingBytes;
		},
		unpad: function(data) {
			var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
			data.sigBytes -= nPaddingBytes;
		}
	};
	CryptoJS.pad.Iso10126 = {
		pad: function(data, blockSize) {
			var blockSizeBytes = blockSize * 4;
			var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
			data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
		},
		unpad: function(data) {
			var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;
			data.sigBytes -= nPaddingBytes;
		}
	};
	CryptoJS.pad.Iso97971 = {
		pad: function(data, blockSize) {
			data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));
			CryptoJS.pad.ZeroPadding.pad(data, blockSize);
		},
		unpad: function(data) {
			CryptoJS.pad.ZeroPadding.unpad(data);
			data.sigBytes--;
		}
	};
	CryptoJS.mode.OFB = (function() {
		var OFB = CryptoJS.lib.BlockCipherMode.extend();
		var Encryptor = OFB.Encryptor = OFB.extend({
			processBlock: function(words, offset) {
				var cipher = this._cipher;
				var blockSize = cipher.blockSize;
				var iv = this._iv;
				var keystream = this._keystream;
				if (iv) {
					keystream = this._keystream = iv.slice(0);
					this._iv = undefined;
				}
				cipher.encryptBlock(keystream, 0);
				for (var i = 0; i < blockSize; i++) {
					words[offset + i] ^= keystream[i];
				}
			}
		});
		OFB.Decryptor = Encryptor;
		return OFB;
	}());
	CryptoJS.pad.NoPadding = {
		pad: function() {},
		unpad: function() {}
	};
	(function(undefined) {
		var C = CryptoJS;
		var C_lib = C.lib;
		var CipherParams = C_lib.CipherParams;
		var C_enc = C.enc;
		var Hex = C_enc.Hex;
		var C_format = C.format;
		var HexFormatter = C_format.Hex = {
			stringify: function(cipherParams) {
				return cipherParams.ciphertext.toString(Hex);
			},
			parse: function(input) {
				var ciphertext = Hex.parse(input);
				return CipherParams.create({
					ciphertext: ciphertext
				});
			}
		};
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var BlockCipher = C_lib.BlockCipher;
		var C_algo = C.algo;
		var SBOX = [];
		var INV_SBOX = [];
		var SUB_MIX_0 = [];
		var SUB_MIX_1 = [];
		var SUB_MIX_2 = [];
		var SUB_MIX_3 = [];
		var INV_SUB_MIX_0 = [];
		var INV_SUB_MIX_1 = [];
		var INV_SUB_MIX_2 = [];
		var INV_SUB_MIX_3 = [];
		(function() {
			var d = [];
			for (var i = 0; i < 256; i++) {
				if (i < 128) {
					d[i] = i << 1;
				} else {
					d[i] = (i << 1) ^ 0x11b;
				}
			}
			var x = 0;
			var xi = 0;
			for (var i = 0; i < 256; i++) {
				var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
				sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
				SBOX[x] = sx;
				INV_SBOX[sx] = x;
				var x2 = d[x];
				var x4 = d[x2];
				var x8 = d[x4];
				var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
				SUB_MIX_0[x] = (t << 24) | (t >>> 8);
				SUB_MIX_1[x] = (t << 16) | (t >>> 16);
				SUB_MIX_2[x] = (t << 8) | (t >>> 24);
				SUB_MIX_3[x] = t;
				var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
				INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
				INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
				INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
				INV_SUB_MIX_3[sx] = t;
				if (!x) {
					x = xi = 1;
				} else {
					x = x2 ^ d[d[d[x8 ^ x2]]];
					xi ^= d[d[xi]];
				}
			}
		}());
		var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
		var AES = C_algo.AES = BlockCipher.extend({
			_doReset: function() {
				var key = this._key;
				var keyWords = key.words;
				var keySize = key.sigBytes / 4;
				var nRounds = this._nRounds = keySize + 6;
				var ksRows = (nRounds + 1) * 4;
				var keySchedule = this._keySchedule = [];
				for (var ksRow = 0; ksRow < ksRows; ksRow++) {
					if (ksRow < keySize) {
						keySchedule[ksRow] = keyWords[ksRow];
					} else {
						var t = keySchedule[ksRow - 1];
						if (!(ksRow % keySize)) {
							t = (t << 8) | (t >>> 24);
							t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
							t ^= RCON[(ksRow / keySize) | 0] << 24;
						} else if (keySize > 6 && ksRow % keySize == 4) {
							t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
						}
						keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
					}
				}
				var invKeySchedule = this._invKeySchedule = [];
				for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
					var ksRow = ksRows - invKsRow;
					if (invKsRow % 4) {
						var t = keySchedule[ksRow];
					} else {
						var t = keySchedule[ksRow - 4];
					}
					if (invKsRow < 4 || ksRow <= 4) {
						invKeySchedule[invKsRow] = t;
					} else {
						invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^ INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
					}
				}
			},
			encryptBlock: function(M, offset) {
				this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
			},
			decryptBlock: function(M, offset) {
				var t = M[offset + 1];
				M[offset + 1] = M[offset + 3];
				M[offset + 3] = t;
				this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
				var t = M[offset + 1];
				M[offset + 1] = M[offset + 3];
				M[offset + 3] = t;
			},
			_doCryptBlock: function(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
				var nRounds = this._nRounds;
				var s0 = M[offset] ^ keySchedule[0];
				var s1 = M[offset + 1] ^ keySchedule[1];
				var s2 = M[offset + 2] ^ keySchedule[2];
				var s3 = M[offset + 3] ^ keySchedule[3];
				var ksRow = 4;
				for (var round = 1; round < nRounds; round++) {
					var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
					var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
					var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
					var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];
					s0 = t0;
					s1 = t1;
					s2 = t2;
					s3 = t3;
				}
				var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
				var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
				var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
				var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
				M[offset] = t0;
				M[offset + 1] = t1;
				M[offset + 2] = t2;
				M[offset + 3] = t3;
			},
			keySize: 256 / 32
		});
		C.AES = BlockCipher._createHelper(AES);
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var WordArray = C_lib.WordArray;
		var BlockCipher = C_lib.BlockCipher;
		var C_algo = C.algo;
		var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];
		var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];
		var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
		var SBOX_P = [{
			0x0: 0x808200,
			0x10000000: 0x8000,
			0x20000000: 0x808002,
			0x30000000: 0x2,
			0x40000000: 0x200,
			0x50000000: 0x808202,
			0x60000000: 0x800202,
			0x70000000: 0x800000,
			0x80000000: 0x202,
			0x90000000: 0x800200,
			0xa0000000: 0x8200,
			0xb0000000: 0x808000,
			0xc0000000: 0x8002,
			0xd0000000: 0x800002,
			0xe0000000: 0x0,
			0xf0000000: 0x8202,
			0x8000000: 0x0,
			0x18000000: 0x808202,
			0x28000000: 0x8202,
			0x38000000: 0x8000,
			0x48000000: 0x808200,
			0x58000000: 0x200,
			0x68000000: 0x808002,
			0x78000000: 0x2,
			0x88000000: 0x800200,
			0x98000000: 0x8200,
			0xa8000000: 0x808000,
			0xb8000000: 0x800202,
			0xc8000000: 0x800002,
			0xd8000000: 0x8002,
			0xe8000000: 0x202,
			0xf8000000: 0x800000,
			0x1: 0x8000,
			0x10000001: 0x2,
			0x20000001: 0x808200,
			0x30000001: 0x800000,
			0x40000001: 0x808002,
			0x50000001: 0x8200,
			0x60000001: 0x200,
			0x70000001: 0x800202,
			0x80000001: 0x808202,
			0x90000001: 0x808000,
			0xa0000001: 0x800002,
			0xb0000001: 0x8202,
			0xc0000001: 0x202,
			0xd0000001: 0x800200,
			0xe0000001: 0x8002,
			0xf0000001: 0x0,
			0x8000001: 0x808202,
			0x18000001: 0x808000,
			0x28000001: 0x800000,
			0x38000001: 0x200,
			0x48000001: 0x8000,
			0x58000001: 0x800002,
			0x68000001: 0x2,
			0x78000001: 0x8202,
			0x88000001: 0x8002,
			0x98000001: 0x800202,
			0xa8000001: 0x202,
			0xb8000001: 0x808200,
			0xc8000001: 0x800200,
			0xd8000001: 0x0,
			0xe8000001: 0x8200,
			0xf8000001: 0x808002
		}, {
			0x0: 0x40084010,
			0x1000000: 0x4000,
			0x2000000: 0x80000,
			0x3000000: 0x40080010,
			0x4000000: 0x40000010,
			0x5000000: 0x40084000,
			0x6000000: 0x40004000,
			0x7000000: 0x10,
			0x8000000: 0x84000,
			0x9000000: 0x40004010,
			0xa000000: 0x40000000,
			0xb000000: 0x84010,
			0xc000000: 0x80010,
			0xd000000: 0x0,
			0xe000000: 0x4010,
			0xf000000: 0x40080000,
			0x800000: 0x40004000,
			0x1800000: 0x84010,
			0x2800000: 0x10,
			0x3800000: 0x40004010,
			0x4800000: 0x40084010,
			0x5800000: 0x40000000,
			0x6800000: 0x80000,
			0x7800000: 0x40080010,
			0x8800000: 0x80010,
			0x9800000: 0x0,
			0xa800000: 0x4000,
			0xb800000: 0x40080000,
			0xc800000: 0x40000010,
			0xd800000: 0x84000,
			0xe800000: 0x40084000,
			0xf800000: 0x4010,
			0x10000000: 0x0,
			0x11000000: 0x40080010,
			0x12000000: 0x40004010,
			0x13000000: 0x40084000,
			0x14000000: 0x40080000,
			0x15000000: 0x10,
			0x16000000: 0x84010,
			0x17000000: 0x4000,
			0x18000000: 0x4010,
			0x19000000: 0x80000,
			0x1a000000: 0x80010,
			0x1b000000: 0x40000010,
			0x1c000000: 0x84000,
			0x1d000000: 0x40004000,
			0x1e000000: 0x40000000,
			0x1f000000: 0x40084010,
			0x10800000: 0x84010,
			0x11800000: 0x80000,
			0x12800000: 0x40080000,
			0x13800000: 0x4000,
			0x14800000: 0x40004000,
			0x15800000: 0x40084010,
			0x16800000: 0x10,
			0x17800000: 0x40000000,
			0x18800000: 0x40084000,
			0x19800000: 0x40000010,
			0x1a800000: 0x40004010,
			0x1b800000: 0x80010,
			0x1c800000: 0x0,
			0x1d800000: 0x4010,
			0x1e800000: 0x40080010,
			0x1f800000: 0x84000
		}, {
			0x0: 0x104,
			0x100000: 0x0,
			0x200000: 0x4000100,
			0x300000: 0x10104,
			0x400000: 0x10004,
			0x500000: 0x4000004,
			0x600000: 0x4010104,
			0x700000: 0x4010000,
			0x800000: 0x4000000,
			0x900000: 0x4010100,
			0xa00000: 0x10100,
			0xb00000: 0x4010004,
			0xc00000: 0x4000104,
			0xd00000: 0x10000,
			0xe00000: 0x4,
			0xf00000: 0x100,
			0x80000: 0x4010100,
			0x180000: 0x4010004,
			0x280000: 0x0,
			0x380000: 0x4000100,
			0x480000: 0x4000004,
			0x580000: 0x10000,
			0x680000: 0x10004,
			0x780000: 0x104,
			0x880000: 0x4,
			0x980000: 0x100,
			0xa80000: 0x4010000,
			0xb80000: 0x10104,
			0xc80000: 0x10100,
			0xd80000: 0x4000104,
			0xe80000: 0x4010104,
			0xf80000: 0x4000000,
			0x1000000: 0x4010100,
			0x1100000: 0x10004,
			0x1200000: 0x10000,
			0x1300000: 0x4000100,
			0x1400000: 0x100,
			0x1500000: 0x4010104,
			0x1600000: 0x4000004,
			0x1700000: 0x0,
			0x1800000: 0x4000104,
			0x1900000: 0x4000000,
			0x1a00000: 0x4,
			0x1b00000: 0x10100,
			0x1c00000: 0x4010000,
			0x1d00000: 0x104,
			0x1e00000: 0x10104,
			0x1f00000: 0x4010004,
			0x1080000: 0x4000000,
			0x1180000: 0x104,
			0x1280000: 0x4010100,
			0x1380000: 0x0,
			0x1480000: 0x10004,
			0x1580000: 0x4000100,
			0x1680000: 0x100,
			0x1780000: 0x4010004,
			0x1880000: 0x10000,
			0x1980000: 0x4010104,
			0x1a80000: 0x10104,
			0x1b80000: 0x4000004,
			0x1c80000: 0x4000104,
			0x1d80000: 0x4010000,
			0x1e80000: 0x4,
			0x1f80000: 0x10100
		}, {
			0x0: 0x80401000,
			0x10000: 0x80001040,
			0x20000: 0x401040,
			0x30000: 0x80400000,
			0x40000: 0x0,
			0x50000: 0x401000,
			0x60000: 0x80000040,
			0x70000: 0x400040,
			0x80000: 0x80000000,
			0x90000: 0x400000,
			0xa0000: 0x40,
			0xb0000: 0x80001000,
			0xc0000: 0x80400040,
			0xd0000: 0x1040,
			0xe0000: 0x1000,
			0xf0000: 0x80401040,
			0x8000: 0x80001040,
			0x18000: 0x40,
			0x28000: 0x80400040,
			0x38000: 0x80001000,
			0x48000: 0x401000,
			0x58000: 0x80401040,
			0x68000: 0x0,
			0x78000: 0x80400000,
			0x88000: 0x1000,
			0x98000: 0x80401000,
			0xa8000: 0x400000,
			0xb8000: 0x1040,
			0xc8000: 0x80000000,
			0xd8000: 0x400040,
			0xe8000: 0x401040,
			0xf8000: 0x80000040,
			0x100000: 0x400040,
			0x110000: 0x401000,
			0x120000: 0x80000040,
			0x130000: 0x0,
			0x140000: 0x1040,
			0x150000: 0x80400040,
			0x160000: 0x80401000,
			0x170000: 0x80001040,
			0x180000: 0x80401040,
			0x190000: 0x80000000,
			0x1a0000: 0x80400000,
			0x1b0000: 0x401040,
			0x1c0000: 0x80001000,
			0x1d0000: 0x400000,
			0x1e0000: 0x40,
			0x1f0000: 0x1000,
			0x108000: 0x80400000,
			0x118000: 0x80401040,
			0x128000: 0x0,
			0x138000: 0x401000,
			0x148000: 0x400040,
			0x158000: 0x80000000,
			0x168000: 0x80001040,
			0x178000: 0x40,
			0x188000: 0x80000040,
			0x198000: 0x1000,
			0x1a8000: 0x80001000,
			0x1b8000: 0x80400040,
			0x1c8000: 0x1040,
			0x1d8000: 0x80401000,
			0x1e8000: 0x400000,
			0x1f8000: 0x401040
		}, {
			0x0: 0x80,
			0x1000: 0x1040000,
			0x2000: 0x40000,
			0x3000: 0x20000000,
			0x4000: 0x20040080,
			0x5000: 0x1000080,
			0x6000: 0x21000080,
			0x7000: 0x40080,
			0x8000: 0x1000000,
			0x9000: 0x20040000,
			0xa000: 0x20000080,
			0xb000: 0x21040080,
			0xc000: 0x21040000,
			0xd000: 0x0,
			0xe000: 0x1040080,
			0xf000: 0x21000000,
			0x800: 0x1040080,
			0x1800: 0x21000080,
			0x2800: 0x80,
			0x3800: 0x1040000,
			0x4800: 0x40000,
			0x5800: 0x20040080,
			0x6800: 0x21040000,
			0x7800: 0x20000000,
			0x8800: 0x20040000,
			0x9800: 0x0,
			0xa800: 0x21040080,
			0xb800: 0x1000080,
			0xc800: 0x20000080,
			0xd800: 0x21000000,
			0xe800: 0x1000000,
			0xf800: 0x40080,
			0x10000: 0x40000,
			0x11000: 0x80,
			0x12000: 0x20000000,
			0x13000: 0x21000080,
			0x14000: 0x1000080,
			0x15000: 0x21040000,
			0x16000: 0x20040080,
			0x17000: 0x1000000,
			0x18000: 0x21040080,
			0x19000: 0x21000000,
			0x1a000: 0x1040000,
			0x1b000: 0x20040000,
			0x1c000: 0x40080,
			0x1d000: 0x20000080,
			0x1e000: 0x0,
			0x1f000: 0x1040080,
			0x10800: 0x21000080,
			0x11800: 0x1000000,
			0x12800: 0x1040000,
			0x13800: 0x20040080,
			0x14800: 0x20000000,
			0x15800: 0x1040080,
			0x16800: 0x80,
			0x17800: 0x21040000,
			0x18800: 0x40080,
			0x19800: 0x21040080,
			0x1a800: 0x0,
			0x1b800: 0x21000000,
			0x1c800: 0x1000080,
			0x1d800: 0x40000,
			0x1e800: 0x20040000,
			0x1f800: 0x20000080
		}, {
			0x0: 0x10000008,
			0x100: 0x2000,
			0x200: 0x10200000,
			0x300: 0x10202008,
			0x400: 0x10002000,
			0x500: 0x200000,
			0x600: 0x200008,
			0x700: 0x10000000,
			0x800: 0x0,
			0x900: 0x10002008,
			0xa00: 0x202000,
			0xb00: 0x8,
			0xc00: 0x10200008,
			0xd00: 0x202008,
			0xe00: 0x2008,
			0xf00: 0x10202000,
			0x80: 0x10200000,
			0x180: 0x10202008,
			0x280: 0x8,
			0x380: 0x200000,
			0x480: 0x202008,
			0x580: 0x10000008,
			0x680: 0x10002000,
			0x780: 0x2008,
			0x880: 0x200008,
			0x980: 0x2000,
			0xa80: 0x10002008,
			0xb80: 0x10200008,
			0xc80: 0x0,
			0xd80: 0x10202000,
			0xe80: 0x202000,
			0xf80: 0x10000000,
			0x1000: 0x10002000,
			0x1100: 0x10200008,
			0x1200: 0x10202008,
			0x1300: 0x2008,
			0x1400: 0x200000,
			0x1500: 0x10000000,
			0x1600: 0x10000008,
			0x1700: 0x202000,
			0x1800: 0x202008,
			0x1900: 0x0,
			0x1a00: 0x8,
			0x1b00: 0x10200000,
			0x1c00: 0x2000,
			0x1d00: 0x10002008,
			0x1e00: 0x10202000,
			0x1f00: 0x200008,
			0x1080: 0x8,
			0x1180: 0x202000,
			0x1280: 0x200000,
			0x1380: 0x10000008,
			0x1480: 0x10002000,
			0x1580: 0x2008,
			0x1680: 0x10202008,
			0x1780: 0x10200000,
			0x1880: 0x10202000,
			0x1980: 0x10200008,
			0x1a80: 0x2000,
			0x1b80: 0x202008,
			0x1c80: 0x200008,
			0x1d80: 0x0,
			0x1e80: 0x10000000,
			0x1f80: 0x10002008
		}, {
			0x0: 0x100000,
			0x10: 0x2000401,
			0x20: 0x400,
			0x30: 0x100401,
			0x40: 0x2100401,
			0x50: 0x0,
			0x60: 0x1,
			0x70: 0x2100001,
			0x80: 0x2000400,
			0x90: 0x100001,
			0xa0: 0x2000001,
			0xb0: 0x2100400,
			0xc0: 0x2100000,
			0xd0: 0x401,
			0xe0: 0x100400,
			0xf0: 0x2000000,
			0x8: 0x2100001,
			0x18: 0x0,
			0x28: 0x2000401,
			0x38: 0x2100400,
			0x48: 0x100000,
			0x58: 0x2000001,
			0x68: 0x2000000,
			0x78: 0x401,
			0x88: 0x100401,
			0x98: 0x2000400,
			0xa8: 0x2100000,
			0xb8: 0x100001,
			0xc8: 0x400,
			0xd8: 0x2100401,
			0xe8: 0x1,
			0xf8: 0x100400,
			0x100: 0x2000000,
			0x110: 0x100000,
			0x120: 0x2000401,
			0x130: 0x2100001,
			0x140: 0x100001,
			0x150: 0x2000400,
			0x160: 0x2100400,
			0x170: 0x100401,
			0x180: 0x401,
			0x190: 0x2100401,
			0x1a0: 0x100400,
			0x1b0: 0x1,
			0x1c0: 0x0,
			0x1d0: 0x2100000,
			0x1e0: 0x2000001,
			0x1f0: 0x400,
			0x108: 0x100400,
			0x118: 0x2000401,
			0x128: 0x2100001,
			0x138: 0x1,
			0x148: 0x2000000,
			0x158: 0x100000,
			0x168: 0x401,
			0x178: 0x2100400,
			0x188: 0x2000001,
			0x198: 0x2100000,
			0x1a8: 0x0,
			0x1b8: 0x2100401,
			0x1c8: 0x100401,
			0x1d8: 0x400,
			0x1e8: 0x2000400,
			0x1f8: 0x100001
		}, {
			0x0: 0x8000820,
			0x1: 0x20000,
			0x2: 0x8000000,
			0x3: 0x20,
			0x4: 0x20020,
			0x5: 0x8020820,
			0x6: 0x8020800,
			0x7: 0x800,
			0x8: 0x8020000,
			0x9: 0x8000800,
			0xa: 0x20800,
			0xb: 0x8020020,
			0xc: 0x820,
			0xd: 0x0,
			0xe: 0x8000020,
			0xf: 0x20820,
			0x80000000: 0x800,
			0x80000001: 0x8020820,
			0x80000002: 0x8000820,
			0x80000003: 0x8000000,
			0x80000004: 0x8020000,
			0x80000005: 0x20800,
			0x80000006: 0x20820,
			0x80000007: 0x20,
			0x80000008: 0x8000020,
			0x80000009: 0x820,
			0x8000000a: 0x20020,
			0x8000000b: 0x8020800,
			0x8000000c: 0x0,
			0x8000000d: 0x8020020,
			0x8000000e: 0x8000800,
			0x8000000f: 0x20000,
			0x10: 0x20820,
			0x11: 0x8020800,
			0x12: 0x20,
			0x13: 0x800,
			0x14: 0x8000800,
			0x15: 0x8000020,
			0x16: 0x8020020,
			0x17: 0x20000,
			0x18: 0x0,
			0x19: 0x20020,
			0x1a: 0x8020000,
			0x1b: 0x8000820,
			0x1c: 0x8020820,
			0x1d: 0x20800,
			0x1e: 0x820,
			0x1f: 0x8000000,
			0x80000010: 0x20000,
			0x80000011: 0x800,
			0x80000012: 0x8020020,
			0x80000013: 0x20820,
			0x80000014: 0x20,
			0x80000015: 0x8020000,
			0x80000016: 0x8000000,
			0x80000017: 0x8000820,
			0x80000018: 0x8020820,
			0x80000019: 0x8000020,
			0x8000001a: 0x8000800,
			0x8000001b: 0x0,
			0x8000001c: 0x20800,
			0x8000001d: 0x820,
			0x8000001e: 0x20020,
			0x8000001f: 0x8020800
		}];
		var SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f];
		var DES = C_algo.DES = BlockCipher.extend({
			_doReset: function() {
				var key = this._key;
				var keyWords = key.words;
				var keyBits = [];
				for (var i = 0; i < 56; i++) {
					var keyBitPos = PC1[i] - 1;
					keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
				}
				var subKeys = this._subKeys = [];
				for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
					var subKey = subKeys[nSubKey] = [];
					var bitShift = BIT_SHIFTS[nSubKey];
					for (var i = 0; i < 24; i++) {
						subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);
						subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
					}
					subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
					for (var i = 1; i < 7; i++) {
						subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
					}
					subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
				}
				var invSubKeys = this._invSubKeys = [];
				for (var i = 0; i < 16; i++) {
					invSubKeys[i] = subKeys[15 - i];
				}
			},
			encryptBlock: function(M, offset) {
				this._doCryptBlock(M, offset, this._subKeys);
			},
			decryptBlock: function(M, offset) {
				this._doCryptBlock(M, offset, this._invSubKeys);
			},
			_doCryptBlock: function(M, offset, subKeys) {
				this._lBlock = M[offset];
				this._rBlock = M[offset + 1];
				exchangeLR.call(this, 4, 0x0f0f0f0f);
				exchangeLR.call(this, 16, 0x0000ffff);
				exchangeRL.call(this, 2, 0x33333333);
				exchangeRL.call(this, 8, 0x00ff00ff);
				exchangeLR.call(this, 1, 0x55555555);
				for (var round = 0; round < 16; round++) {
					var subKey = subKeys[round];
					var lBlock = this._lBlock;
					var rBlock = this._rBlock;
					var f = 0;
					for (var i = 0; i < 8; i++) {
						f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
					}
					this._lBlock = rBlock;
					this._rBlock = lBlock ^ f;
				}
				var t = this._lBlock;
				this._lBlock = this._rBlock;
				this._rBlock = t;
				exchangeLR.call(this, 1, 0x55555555);
				exchangeRL.call(this, 8, 0x00ff00ff);
				exchangeRL.call(this, 2, 0x33333333);
				exchangeLR.call(this, 16, 0x0000ffff);
				exchangeLR.call(this, 4, 0x0f0f0f0f);
				M[offset] = this._lBlock;
				M[offset + 1] = this._rBlock;
			},
			keySize: 64 / 32,
			ivSize: 64 / 32,
			blockSize: 64 / 32
		});

		function exchangeLR(offset, mask) {
			var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
			this._rBlock ^= t;
			this._lBlock ^= t << offset;
		};

		function exchangeRL(offset, mask) {
			var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
			this._lBlock ^= t;
			this._rBlock ^= t << offset;
		};
		C.DES = BlockCipher._createHelper(DES);
		var TripleDES = C_algo.TripleDES = BlockCipher.extend({
			_doReset: function() {
				var key = this._key;
				var keyWords = key.words;
				this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
				this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
				this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
			},
			encryptBlock: function(M, offset) {
				this._des1.encryptBlock(M, offset);
				this._des2.decryptBlock(M, offset);
				this._des3.encryptBlock(M, offset);
			},
			decryptBlock: function(M, offset) {
				this._des3.decryptBlock(M, offset);
				this._des2.encryptBlock(M, offset);
				this._des1.decryptBlock(M, offset);
			},
			keySize: 192 / 32,
			ivSize: 64 / 32,
			blockSize: 64 / 32
		});
		C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var StreamCipher = C_lib.StreamCipher;
		var C_algo = C.algo;
		var RC4 = C_algo.RC4 = StreamCipher.extend({
			_doReset: function() {
				var key = this._key;
				var keyWords = key.words;
				var keySigBytes = key.sigBytes;
				var S = this._S = [];
				for (var i = 0; i < 256; i++) {
					S[i] = i;
				}
				for (var i = 0, j = 0; i < 256; i++) {
					var keyByteIndex = i % keySigBytes;
					var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;
					j = (j + S[i] + keyByte) % 256;
					var t = S[i];
					S[i] = S[j];
					S[j] = t;
				}
				this._i = this._j = 0;
			},
			_doProcessBlock: function(M, offset) {
				M[offset] ^= generateKeystreamWord.call(this);
			},
			keySize: 256 / 32,
			ivSize: 0
		});

		function generateKeystreamWord() {
			var S = this._S;
			var i = this._i;
			var j = this._j;
			var keystreamWord = 0;
			for (var n = 0; n < 4; n++) {
				i = (i + 1) % 256;
				j = (j + S[i]) % 256;
				var t = S[i];
				S[i] = S[j];
				S[j] = t;
				keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
			}
			this._i = i;
			this._j = j;
			return keystreamWord;
		};
		C.RC4 = StreamCipher._createHelper(RC4);
		var RC4Drop = C_algo.RC4Drop = RC4.extend({
			cfg: RC4.cfg.extend({
				drop: 192
			}),
			_doReset: function() {
				RC4._doReset.call(this);
				for (var i = this.cfg.drop; i > 0; i--) {
					generateKeystreamWord.call(this);
				}
			}
		});
		C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());
	CryptoJS.mode.CTRGladman = (function() {
		var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word) {
			if (((word >> 24) & 0xff) === 0xff) {
				var b1 = (word >> 16) & 0xff;
				var b2 = (word >> 8) & 0xff;
				var b3 = word & 0xff;
				if (b1 === 0xff) {
					b1 = 0;
					if (b2 === 0xff) {
						b2 = 0;
						if (b3 === 0xff) {
							b3 = 0;
						} else {
							++b3;
						}
					} else {
						++b2;
					}
				} else {
					++b1;
				}
				word = 0;
				word += (b1 << 16);
				word += (b2 << 8);
				word += b3;
			} else {
				word += (0x01 << 24);
			}
			return word;
		};

		function incCounter(counter) {
			if ((counter[0] = incWord(counter[0])) === 0) {
				counter[1] = incWord(counter[1]);
			}
			return counter;
		};
		var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
			processBlock: function(words, offset) {
				var cipher = this._cipher;
				var blockSize = cipher.blockSize;
				var iv = this._iv;
				var counter = this._counter;
				if (iv) {
					counter = this._counter = iv.slice(0);
					this._iv = undefined;
				}
				incCounter(counter);
				var keystream = counter.slice(0);
				cipher.encryptBlock(keystream, 0);
				for (var i = 0; i < blockSize; i++) {
					words[offset + i] ^= keystream[i];
				}
			}
		});
		CTRGladman.Decryptor = Encryptor;
		return CTRGladman;
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var StreamCipher = C_lib.StreamCipher;
		var C_algo = C.algo;
		var S = [];
		var C_ = [];
		var G = [];
		var Rabbit = C_algo.Rabbit = StreamCipher.extend({
			_doReset: function() {
				var K = this._key.words;
				var iv = this.cfg.iv;
				for (var i = 0; i < 4; i++) {
					K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff) | (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);
				}
				var X = this._X = [K[0], (K[3] << 16) | (K[2] >>> 16), K[1], (K[0] << 16) | (K[3] >>> 16), K[2], (K[1] << 16) | (K[0] >>> 16), K[3], (K[2] << 16) | (K[1] >>> 16)];
				var C = this._C = [(K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff), (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff), (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff), (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)];
				this._b = 0;
				for (var i = 0; i < 4; i++) {
					nextState.call(this);
				}
				for (var i = 0; i < 8; i++) {
					C[i] ^= X[(i + 4) & 7];
				}
				if (iv) {
					var IV = iv.words;
					var IV_0 = IV[0];
					var IV_1 = IV[1];
					var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
					var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
					var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
					var i3 = (i2 << 16) | (i0 & 0x0000ffff);
					C[0] ^= i0;
					C[1] ^= i1;
					C[2] ^= i2;
					C[3] ^= i3;
					C[4] ^= i0;
					C[5] ^= i1;
					C[6] ^= i2;
					C[7] ^= i3;
					for (var i = 0; i < 4; i++) {
						nextState.call(this);
					}
				}
			},
			_doProcessBlock: function(M, offset) {
				var X = this._X;
				nextState.call(this);
				S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
				S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
				S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
				S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
				for (var i = 0; i < 4; i++) {
					S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);
					M[offset + i] ^= S[i];
				}
			},
			blockSize: 128 / 32,
			ivSize: 64 / 32
		});

		function nextState() {
			var X = this._X;
			var C = this._C;
			for (var i = 0; i < 8; i++) {
				C_[i] = C[i];
			}
			C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
			C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
			C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
			C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
			C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
			C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
			C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
			C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
			this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
			for (var i = 0; i < 8; i++) {
				var gx = X[i] + C[i];
				var ga = gx & 0xffff;
				var gb = gx >>> 16;
				var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
				var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
				G[i] = gh ^ gl;
			}
			X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
			X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
			X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
			X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
			X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
			X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
			X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
			X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
		};
		C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());
	CryptoJS.mode.CTR = (function() {
		var CTR = CryptoJS.lib.BlockCipherMode.extend();
		var Encryptor = CTR.Encryptor = CTR.extend({
			processBlock: function(words, offset) {
				var cipher = this._cipher;
				var blockSize = cipher.blockSize;
				var iv = this._iv;
				var counter = this._counter;
				if (iv) {
					counter = this._counter = iv.slice(0);
					this._iv = undefined;
				}
				var keystream = counter.slice(0);
				cipher.encryptBlock(keystream, 0);
				counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;
				for (var i = 0; i < blockSize; i++) {
					words[offset + i] ^= keystream[i];
				}
			}
		});
		CTR.Decryptor = Encryptor;
		return CTR;
	}());
	(function() {
		var C = CryptoJS;
		var C_lib = C.lib;
		var StreamCipher = C_lib.StreamCipher;
		var C_algo = C.algo;
		var S = [];
		var C_ = [];
		var G = [];
		var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
			_doReset: function() {
				var K = this._key.words;
				var iv = this.cfg.iv;
				var X = this._X = [K[0], (K[3] << 16) | (K[2] >>> 16), K[1], (K[0] << 16) | (K[3] >>> 16), K[2], (K[1] << 16) | (K[0] >>> 16), K[3], (K[2] << 16) | (K[1] >>> 16)];
				var C = this._C = [(K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff), (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff), (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff), (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)];
				this._b = 0;
				for (var i = 0; i < 4; i++) {
					nextState.call(this);
				}
				for (var i = 0; i < 8; i++) {
					C[i] ^= X[(i + 4) & 7];
				}
				if (iv) {
					var IV = iv.words;
					var IV_0 = IV[0];
					var IV_1 = IV[1];
					var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
					var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
					var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
					var i3 = (i2 << 16) | (i0 & 0x0000ffff);
					C[0] ^= i0;
					C[1] ^= i1;
					C[2] ^= i2;
					C[3] ^= i3;
					C[4] ^= i0;
					C[5] ^= i1;
					C[6] ^= i2;
					C[7] ^= i3;
					for (var i = 0; i < 4; i++) {
						nextState.call(this);
					}
				}
			},
			_doProcessBlock: function(M, offset) {
				var X = this._X;
				nextState.call(this);
				S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
				S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
				S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
				S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);
				for (var i = 0; i < 4; i++) {
					S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);
					M[offset + i] ^= S[i];
				}
			},
			blockSize: 128 / 32,
			ivSize: 64 / 32
		});

		function nextState() {
			var X = this._X;
			var C = this._C;
			for (var i = 0; i < 8; i++) {
				C_[i] = C[i];
			}
			C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
			C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
			C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
			C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
			C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
			C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
			C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
			C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
			this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;
			for (var i = 0; i < 8; i++) {
				var gx = X[i] + C[i];
				var ga = gx & 0xffff;
				var gb = gx >>> 16;
				var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
				var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);
				G[i] = gh ^ gl;
			}
			X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
			X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
			X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
			X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
			X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
			X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
			X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
			X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
		};
		C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());
	CryptoJS.pad.ZeroPadding = {
		pad: function(data, blockSize) {
			var blockSizeBytes = blockSize * 4;
			data.clamp();
			data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
		},
		unpad: function(data) {
			var dataWords = data.words;
			var i = data.sigBytes - 1;
			while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
				i--;
			}
			data.sigBytes = i + 1;
		}
	};
	return CryptoJS;
}));
var JSEncryptExports = {};
(function(exports) {
	var dbits;
	var canary = 0xdeadbeefcafe;
	var j_lm = ((canary & 0xffffff) == 0xefcafe);

	function BigInteger(a, b, c) {
		if (a != null) if ("number" == typeof a) this.fromNumber(a, b, c);
		else if (b == null && "string" != typeof a) this.fromString(a, 256);
		else this.fromString(a, b);
	};

	function nbi() {
		return new BigInteger(null);
	};

	function am1(i, x, w, j, c, n) {
		while (--n >= 0) {
			var v = x * this[i++] + w[j] + c;
			c = Math.floor(v / 0x4000000);
			w[j++] = v & 0x3ffffff;
		}
		return c;
	};

	function am2(i, x, w, j, c, n) {
		var xl = x & 0x7fff,
			xh = x >> 15;
		while (--n >= 0) {
			var l = this[i] & 0x7fff;
			var h = this[i++] >> 15;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
			c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
			w[j++] = l & 0x3fffffff;
		}
		return c;
	};

	function am3(i, x, w, j, c, n) {
		var xl = x & 0x3fff,
			xh = x >> 14;
		while (--n >= 0) {
			var l = this[i] & 0x3fff;
			var h = this[i++] >> 14;
			var m = xh * l + h * xl;
			l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
			c = (l >> 28) + (m >> 14) + xh * h;
			w[j++] = l & 0xfffffff;
		}
		return c;
	};
	if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
		BigInteger.prototype.am = am2;
		dbits = 30;
	} else if (j_lm && (navigator.appName != "Netscape")) {
		BigInteger.prototype.am = am1;
		dbits = 26;
	} else {
		BigInteger.prototype.am = am3;
		dbits = 28;
	}
	BigInteger.prototype.DB = dbits;
	BigInteger.prototype.DM = ((1 << dbits) - 1);
	BigInteger.prototype.DV = (1 << dbits);
	var BI_FP = 52;
	BigInteger.prototype.FV = Math.pow(2, BI_FP);
	BigInteger.prototype.F1 = BI_FP - dbits;
	BigInteger.prototype.F2 = 2 * dbits - BI_FP;
	var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
	var BI_RC = new Array();
	var rr, vv;
	rr = "0".charCodeAt(0);
	for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
	rr = "a".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
	rr = "A".charCodeAt(0);
	for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

	function int2char(n) {
		return BI_RM.charAt(n);
	};

	function intAt(s, i) {
		var c = BI_RC[s.charCodeAt(i)];
		return (c == null) ? -1 : c;
	};

	function bnpCopyTo(r) {
		for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
		r.t = this.t;
		r.s = this.s;
	};

	function bnpFromInt(x) {
		this.t = 1;
		this.s = (x < 0) ? -1 : 0;
		if (x > 0) this[0] = x;
		else if (x < -1) this[0] = x + this.DV;
		else this.t = 0;
	};

	function nbv(i) {
		var r = nbi();
		r.fromInt(i);
		return r;
	};

	function bnpFromString(s, b) {
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 256) k = 8;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else {
			this.fromRadix(s, b);
			return;
		}
		this.t = 0;
		this.s = 0;
		var i = s.length,
			mi = false,
			sh = 0;
		while (--i >= 0) {
			var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-") mi = true;
				continue;
			}
			mi = false;
			if (sh == 0) this[this.t++] = x;
			else if (sh + k > this.DB) {
				this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
				this[this.t++] = (x >> (this.DB - sh));
			} else this[this.t - 1] |= x << sh;
			sh += k;
			if (sh >= this.DB) sh -= this.DB;
		}
		if (k == 8 && (s[0] & 0x80) != 0) {
			this.s = -1;
			if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
		}
		this.clamp();
		if (mi) BigInteger.ZERO.subTo(this, this);
	};

	function bnpClamp() {
		var c = this.s & this.DM;
		while (this.t > 0 && this[this.t - 1] == c)--this.t;
	};

	function bnToString(b) {
		if (this.s < 0) return "-" + this.negate().toString(b);
		var k;
		if (b == 16) k = 4;
		else if (b == 8) k = 3;
		else if (b == 2) k = 1;
		else if (b == 32) k = 5;
		else if (b == 4) k = 2;
		else return this.toRadix(b);
		var km = (1 << k) - 1,
			d, m = false,
			r = "",
			i = this.t;
		var p = this.DB - (i * this.DB) % k;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) > 0) {
				m = true;
				r = int2char(d);
			}
			while (i >= 0) {
				if (p < k) {
					d = (this[i] & ((1 << p) - 1)) << (k - p);
					d |= this[--i] >> (p += this.DB - k);
				} else {
					d = (this[i] >> (p -= k)) & km;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if (d > 0) m = true;
				if (m) r += int2char(d);
			}
		}
		return m ? r : "0";
	};

	function bnNegate() {
		var r = nbi();
		BigInteger.ZERO.subTo(this, r);
		return r;
	};

	function bnAbs() {
		return (this.s < 0) ? this.negate() : this;
	};

	function bnCompareTo(a) {
		var r = this.s - a.s;
		if (r != 0) return r;
		var i = this.t;
		r = i - a.t;
		if (r != 0) return (this.s < 0) ? -r : r;
		while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
		return 0;
	};

	function nbits(x) {
		var r = 1,
			t;
		if ((t = x >>> 16) != 0) {
			x = t;
			r += 16;
		}
		if ((t = x >> 8) != 0) {
			x = t;
			r += 8;
		}
		if ((t = x >> 4) != 0) {
			x = t;
			r += 4;
		}
		if ((t = x >> 2) != 0) {
			x = t;
			r += 2;
		}
		if ((t = x >> 1) != 0) {
			x = t;
			r += 1;
		}
		return r;
	};

	function bnBitLength() {
		if (this.t <= 0) return 0;
		return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
	};

	function bnpDLShiftTo(n, r) {
		var i;
		for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
		for (i = n - 1; i >= 0; --i) r[i] = 0;
		r.t = this.t + n;
		r.s = this.s;
	};

	function bnpDRShiftTo(n, r) {
		for (var i = n; i < this.t; ++i) r[i - n] = this[i];
		r.t = Math.max(this.t - n, 0);
		r.s = this.s;
	};

	function bnpLShiftTo(n, r) {
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << cbs) - 1;
		var ds = Math.floor(n / this.DB),
			c = (this.s << bs) & this.DM,
			i;
		for (i = this.t - 1; i >= 0; --i) {
			r[i + ds + 1] = (this[i] >> cbs) | c;
			c = (this[i] & bm) << bs;
		}
		for (i = ds - 1; i >= 0; --i) r[i] = 0;
		r[ds] = c;
		r.t = this.t + ds + 1;
		r.s = this.s;
		r.clamp();
	};

	function bnpRShiftTo(n, r) {
		r.s = this.s;
		var ds = Math.floor(n / this.DB);
		if (ds >= this.t) {
			r.t = 0;
			return;
		}
		var bs = n % this.DB;
		var cbs = this.DB - bs;
		var bm = (1 << bs) - 1;
		r[0] = this[ds] >> bs;
		for (var i = ds + 1; i < this.t; ++i) {
			r[i - ds - 1] |= (this[i] & bm) << cbs;
			r[i - ds] = this[i] >> bs;
		}
		if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
		r.t = this.t - ds;
		r.clamp();
	};

	function bnpSubTo(a, r) {
		var i = 0,
			c = 0,
			m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] - a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c -= a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c -= a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c -= a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c < -1) r[i++] = this.DV + c;
		else if (c > 0) r[i++] = c;
		r.t = i;
		r.clamp();
	};

	function bnpMultiplyTo(a, r) {
		var x = this.abs(),
			y = a.abs();
		var i = x.t;
		r.t = i + y.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
		r.s = 0;
		r.clamp();
		if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
	};

	function bnpSquareTo(r) {
		var x = this.abs();
		var i = r.t = 2 * x.t;
		while (--i >= 0) r[i] = 0;
		for (i = 0; i < x.t - 1; ++i) {
			var c = x.am(i, x[i], r, 2 * i, 0, 1);
			if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
				r[i + x.t] -= x.DV;
				r[i + x.t + 1] = 1;
			}
		}
		if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
		r.s = 0;
		r.clamp();
	};

	function bnpDivRemTo(m, q, r) {
		var pm = m.abs();
		if (pm.t <= 0) return;
		var pt = this.abs();
		if (pt.t < pm.t) {
			if (q != null) q.fromInt(0);
			if (r != null) this.copyTo(r);
			return;
		}
		if (r == null) r = nbi();
		var y = nbi(),
			ts = this.s,
			ms = m.s;
		var nsh = this.DB - nbits(pm[pm.t - 1]);
		if (nsh > 0) {
			pm.lShiftTo(nsh, y);
			pt.lShiftTo(nsh, r);
		} else {
			pm.copyTo(y);
			pt.copyTo(r);
		}
		var ys = y.t;
		var y0 = y[ys - 1];
		if (y0 == 0) return;
		var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
		var d1 = this.FV / yt,
			d2 = (1 << this.F1) / yt,
			e = 1 << this.F2;
		var i = r.t,
			j = i - ys,
			t = (q == null) ? nbi() : q;
		y.dlShiftTo(j, t);
		if (r.compareTo(t) >= 0) {
			r[r.t++] = 1;
			r.subTo(t, r);
		}
		BigInteger.ONE.dlShiftTo(ys, t);
		t.subTo(y, y);
		while (y.t < ys) y[y.t++] = 0;
		while (--j >= 0) {
			var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
			if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
				y.dlShiftTo(j, t);
				r.subTo(t, r);
				while (r[i] < --qd) r.subTo(t, r);
			}
		}
		if (q != null) {
			r.drShiftTo(ys, q);
			if (ts != ms) BigInteger.ZERO.subTo(q, q);
		}
		r.t = ys;
		r.clamp();
		if (nsh > 0) r.rShiftTo(nsh, r);
		if (ts < 0) BigInteger.ZERO.subTo(r, r);
	};

	function bnMod(a) {
		var r = nbi();
		this.abs().divRemTo(a, null, r);
		if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
		return r;
	};

	function Classic(m) {
		this.m = m;
	};

	function cConvert(x) {
		if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
		else return x;
	};

	function cRevert(x) {
		return x;
	};

	function cReduce(x) {
		x.divRemTo(this.m, null, x);
	};

	function cMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	};

	function cSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	};
	Classic.prototype.convert = cConvert;
	Classic.prototype.revert = cRevert;
	Classic.prototype.reduce = cReduce;
	Classic.prototype.mulTo = cMulTo;
	Classic.prototype.sqrTo = cSqrTo;

	function bnpInvDigit() {
		if (this.t < 1) return 0;
		var x = this[0];
		if ((x & 1) == 0) return 0;
		var y = x & 3;
		y = (y * (2 - (x & 0xf) * y)) & 0xf;
		y = (y * (2 - (x & 0xff) * y)) & 0xff;
		y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
		y = (y * (2 - x * y % this.DV)) % this.DV;
		return (y > 0) ? this.DV - y : -y;
	};

	function Montgomery(m) {
		this.m = m;
		this.mp = m.invDigit();
		this.mpl = this.mp & 0x7fff;
		this.mph = this.mp >> 15;
		this.um = (1 << (m.DB - 15)) - 1;
		this.mt2 = 2 * m.t;
	};

	function montConvert(x) {
		var r = nbi();
		x.abs().dlShiftTo(this.m.t, r);
		r.divRemTo(this.m, null, r);
		if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
		return r;
	};

	function montRevert(x) {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	};

	function montReduce(x) {
		while (x.t <= this.mt2) x[x.t++] = 0;
		for (var i = 0; i < this.m.t; ++i) {
			var j = x[i] & 0x7fff;
			var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
			j = i + this.m.t;
			x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
			while (x[j] >= x.DV) {
				x[j] -= x.DV;
				x[++j]++;
			}
		}
		x.clamp();
		x.drShiftTo(this.m.t, x);
		if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	};

	function montSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	};

	function montMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	};
	Montgomery.prototype.convert = montConvert;
	Montgomery.prototype.revert = montRevert;
	Montgomery.prototype.reduce = montReduce;
	Montgomery.prototype.mulTo = montMulTo;
	Montgomery.prototype.sqrTo = montSqrTo;

	function bnpIsEven() {
		return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
	};

	function bnpExp(e, z) {
		if (e > 0xffffffff || e < 1) return BigInteger.ONE;
		var r = nbi(),
			r2 = nbi(),
			g = z.convert(this),
			i = nbits(e) - 1;
		g.copyTo(r);
		while (--i >= 0) {
			z.sqrTo(r, r2);
			if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
			else {
				var t = r;
				r = r2;
				r2 = t;
			}
		}
		return z.revert(r);
	};

	function bnModPowInt(e, m) {
		var z;
		if (e < 256 || m.isEven()) z = new Classic(m);
		else z = new Montgomery(m);
		return this.exp(e, z);
	};
	BigInteger.prototype.copyTo = bnpCopyTo;
	BigInteger.prototype.fromInt = bnpFromInt;
	BigInteger.prototype.fromString = bnpFromString;
	BigInteger.prototype.clamp = bnpClamp;
	BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
	BigInteger.prototype.drShiftTo = bnpDRShiftTo;
	BigInteger.prototype.lShiftTo = bnpLShiftTo;
	BigInteger.prototype.rShiftTo = bnpRShiftTo;
	BigInteger.prototype.subTo = bnpSubTo;
	BigInteger.prototype.multiplyTo = bnpMultiplyTo;
	BigInteger.prototype.squareTo = bnpSquareTo;
	BigInteger.prototype.divRemTo = bnpDivRemTo;
	BigInteger.prototype.invDigit = bnpInvDigit;
	BigInteger.prototype.isEven = bnpIsEven;
	BigInteger.prototype.exp = bnpExp;
	BigInteger.prototype.toString = bnToString;
	BigInteger.prototype.negate = bnNegate;
	BigInteger.prototype.abs = bnAbs;
	BigInteger.prototype.compareTo = bnCompareTo;
	BigInteger.prototype.bitLength = bnBitLength;
	BigInteger.prototype.mod = bnMod;
	BigInteger.prototype.modPowInt = bnModPowInt;
	BigInteger.ZERO = nbv(0);
	BigInteger.ONE = nbv(1);

	function bnClone() {
		var r = nbi();
		this.copyTo(r);
		return r;
	};

	function bnIntValue() {
		if (this.s < 0) {
			if (this.t == 1) return this[0] - this.DV;
			else if (this.t == 0) return -1;
		} else if (this.t == 1) return this[0];
		else if (this.t == 0) return 0;
		return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
	};

	function bnByteValue() {
		return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
	};

	function bnShortValue() {
		return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
	};

	function bnpChunkSize(r) {
		return Math.floor(Math.LN2 * this.DB / Math.log(r));
	};

	function bnSigNum() {
		if (this.s < 0) return -1;
		else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
		else return 1;
	};

	function bnpToRadix(b) {
		if (b == null) b = 10;
		if (this.signum() == 0 || b < 2 || b > 36) return "0";
		var cs = this.chunkSize(b);
		var a = Math.pow(b, cs);
		var d = nbv(a),
			y = nbi(),
			z = nbi(),
			r = "";
		this.divRemTo(d, y, z);
		while (y.signum() > 0) {
			r = (a + z.intValue()).toString(b).substr(1) + r;
			y.divRemTo(d, y, z);
		}
		return z.intValue().toString(b) + r;
	};

	function bnpFromRadix(s, b) {
		this.fromInt(0);
		if (b == null) b = 10;
		var cs = this.chunkSize(b);
		var d = Math.pow(b, cs),
			mi = false,
			j = 0,
			w = 0;
		for (var i = 0; i < s.length; ++i) {
			var x = intAt(s, i);
			if (x < 0) {
				if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
				continue;
			}
			w = b * w + x;
			if (++j >= cs) {
				this.dMultiply(d);
				this.dAddOffset(w, 0);
				j = 0;
				w = 0;
			}
		}
		if (j > 0) {
			this.dMultiply(Math.pow(b, j));
			this.dAddOffset(w, 0);
		}
		if (mi) BigInteger.ZERO.subTo(this, this);
	};

	function bnpFromNumber(a, b, c) {
		if ("number" == typeof b) {
			if (a < 2) this.fromInt(1);
			else {
				this.fromNumber(a, c);
				if (!this.testBit(a - 1)) this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
				if (this.isEven()) this.dAddOffset(1, 0);
				while (!this.isProbablePrime(b)) {
					this.dAddOffset(2, 0);
					if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
				}
			}
		} else {
			var x = new Array(),
				t = a & 7;
			x.length = (a >> 3) + 1;
			b.nextBytes(x);
			if (t > 0) x[0] &= ((1 << t) - 1);
			else x[0] = 0;
			this.fromString(x, 256);
		}
	};

	function bnToByteArray() {
		var i = this.t,
			r = new Array();
		r[0] = this.s;
		var p = this.DB - (i * this.DB) % 8,
			d, k = 0;
		if (i-- > 0) {
			if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | (this.s << (this.DB - p));
			while (i >= 0) {
				if (p < 8) {
					d = (this[i] & ((1 << p) - 1)) << (8 - p);
					d |= this[--i] >> (p += this.DB - 8);
				} else {
					d = (this[i] >> (p -= 8)) & 0xff;
					if (p <= 0) {
						p += this.DB;
						--i;
					}
				}
				if ((d & 0x80) != 0) d |= -256;
				if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;
				if (k > 0 || d != this.s) r[k++] = d;
			}
		}
		return r;
	};

	function bnEquals(a) {
		return (this.compareTo(a) == 0);
	};

	function bnMin(a) {
		return (this.compareTo(a) < 0) ? this : a;
	};

	function bnMax(a) {
		return (this.compareTo(a) > 0) ? this : a;
	};

	function bnpBitwiseTo(a, op, r) {
		var i, f, m = Math.min(a.t, this.t);
		for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
		if (a.t < this.t) {
			f = a.s & this.DM;
			for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
			r.t = this.t;
		} else {
			f = this.s & this.DM;
			for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
			r.t = a.t;
		}
		r.s = op(this.s, a.s);
		r.clamp();
	};

	function op_and(x, y) {
		return x & y;
	};

	function bnAnd(a) {
		var r = nbi();
		this.bitwiseTo(a, op_and, r);
		return r;
	};

	function op_or(x, y) {
		return x | y;
	};

	function bnOr(a) {
		var r = nbi();
		this.bitwiseTo(a, op_or, r);
		return r;
	};

	function op_xor(x, y) {
		return x ^ y;
	};

	function bnXor(a) {
		var r = nbi();
		this.bitwiseTo(a, op_xor, r);
		return r;
	};

	function op_andnot(x, y) {
		return x & ~y;
	};

	function bnAndNot(a) {
		var r = nbi();
		this.bitwiseTo(a, op_andnot, r);
		return r;
	};

	function bnNot() {
		var r = nbi();
		for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
		r.t = this.t;
		r.s = ~this.s;
		return r;
	};

	function bnShiftLeft(n) {
		var r = nbi();
		if (n < 0) this.rShiftTo(-n, r);
		else this.lShiftTo(n, r);
		return r;
	};

	function bnShiftRight(n) {
		var r = nbi();
		if (n < 0) this.lShiftTo(-n, r);
		else this.rShiftTo(n, r);
		return r;
	};

	function lbit(x) {
		if (x == 0) return -1;
		var r = 0;
		if ((x & 0xffff) == 0) {
			x >>= 16;
			r += 16;
		}
		if ((x & 0xff) == 0) {
			x >>= 8;
			r += 8;
		}
		if ((x & 0xf) == 0) {
			x >>= 4;
			r += 4;
		}
		if ((x & 3) == 0) {
			x >>= 2;
			r += 2;
		}
		if ((x & 1) == 0)++r;
		return r;
	};

	function bnGetLowestSetBit() {
		for (var i = 0; i < this.t; ++i) if (this[i] != 0) return i * this.DB + lbit(this[i]);
		if (this.s < 0) return this.t * this.DB;
		return -1;
	};

	function cbit(x) {
		var r = 0;
		while (x != 0) {
			x &= x - 1;
			++r;
		}
		return r;
	};

	function bnBitCount() {
		var r = 0,
			x = this.s & this.DM;
		for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
		return r;
	};

	function bnTestBit(n) {
		var j = Math.floor(n / this.DB);
		if (j >= this.t) return (this.s != 0);
		return ((this[j] & (1 << (n % this.DB))) != 0);
	};

	function bnpChangeBit(n, op) {
		var r = BigInteger.ONE.shiftLeft(n);
		this.bitwiseTo(r, op, r);
		return r;
	};

	function bnSetBit(n) {
		return this.changeBit(n, op_or);
	};

	function bnClearBit(n) {
		return this.changeBit(n, op_andnot);
	};

	function bnFlipBit(n) {
		return this.changeBit(n, op_xor);
	};

	function bnpAddTo(a, r) {
		var i = 0,
			c = 0,
			m = Math.min(a.t, this.t);
		while (i < m) {
			c += this[i] + a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		if (a.t < this.t) {
			c += a.s;
			while (i < this.t) {
				c += this[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += this.s;
		} else {
			c += this.s;
			while (i < a.t) {
				c += a[i];
				r[i++] = c & this.DM;
				c >>= this.DB;
			}
			c += a.s;
		}
		r.s = (c < 0) ? -1 : 0;
		if (c > 0) r[i++] = c;
		else if (c < -1) r[i++] = this.DV + c;
		r.t = i;
		r.clamp();
	};

	function bnAdd(a) {
		var r = nbi();
		this.addTo(a, r);
		return r;
	};

	function bnSubtract(a) {
		var r = nbi();
		this.subTo(a, r);
		return r;
	};

	function bnMultiply(a) {
		var r = nbi();
		this.multiplyTo(a, r);
		return r;
	};

	function bnSquare() {
		var r = nbi();
		this.squareTo(r);
		return r;
	};

	function bnDivide(a) {
		var r = nbi();
		this.divRemTo(a, r, null);
		return r;
	};

	function bnRemainder(a) {
		var r = nbi();
		this.divRemTo(a, null, r);
		return r;
	};

	function bnDivideAndRemainder(a) {
		var q = nbi(),
			r = nbi();
		this.divRemTo(a, q, r);
		return new Array(q, r);
	};

	function bnpDMultiply(n) {
		this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
		++this.t;
		this.clamp();
	};

	function bnpDAddOffset(n, w) {
		if (n == 0) return;
		while (this.t <= w) this[this.t++] = 0;
		this[w] += n;
		while (this[w] >= this.DV) {
			this[w] -= this.DV;
			if (++w >= this.t) this[this.t++] = 0;
			++this[w];
		}
	};

	function NullExp() {};

	function nNop(x) {
		return x;
	};

	function nMulTo(x, y, r) {
		x.multiplyTo(y, r);
	};

	function nSqrTo(x, r) {
		x.squareTo(r);
	};
	NullExp.prototype.convert = nNop;
	NullExp.prototype.revert = nNop;
	NullExp.prototype.mulTo = nMulTo;
	NullExp.prototype.sqrTo = nSqrTo;

	function bnPow(e) {
		return this.exp(e, new NullExp());
	};

	function bnpMultiplyLowerTo(a, n, r) {
		var i = Math.min(this.t + a.t, n);
		r.s = 0;
		r.t = i;
		while (i > 0) r[--i] = 0;
		var j;
		for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
		for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);
		r.clamp();
	};

	function bnpMultiplyUpperTo(a, n, r) {
		--n;
		var i = r.t = this.t + a.t - n;
		r.s = 0;
		while (--i >= 0) r[i] = 0;
		for (i = Math.max(n - this.t, 0); i < a.t; ++i) r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
		r.clamp();
		r.drShiftTo(1, r);
	};

	function Barrett(m) {
		this.r2 = nbi();
		this.q3 = nbi();
		BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
		this.mu = this.r2.divide(m);
		this.m = m;
	};

	function barrettConvert(x) {
		if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
		else if (x.compareTo(this.m) < 0) return x;
		else {
			var r = nbi();
			x.copyTo(r);
			this.reduce(r);
			return r;
		}
	};

	function barrettRevert(x) {
		return x;
	};

	function barrettReduce(x) {
		x.drShiftTo(this.m.t - 1, this.r2);
		if (x.t > this.m.t + 1) {
			x.t = this.m.t + 1;
			x.clamp();
		}
		this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
		this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
		while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
		x.subTo(this.r2, x);
		while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
	};

	function barrettSqrTo(x, r) {
		x.squareTo(r);
		this.reduce(r);
	};

	function barrettMulTo(x, y, r) {
		x.multiplyTo(y, r);
		this.reduce(r);
	};
	Barrett.prototype.convert = barrettConvert;
	Barrett.prototype.revert = barrettRevert;
	Barrett.prototype.reduce = barrettReduce;
	Barrett.prototype.mulTo = barrettMulTo;
	Barrett.prototype.sqrTo = barrettSqrTo;

	function bnModPow(e, m) {
		var i = e.bitLength(),
			k, r = nbv(1),
			z;
		if (i <= 0) return r;
		else if (i < 18) k = 1;
		else if (i < 48) k = 3;
		else if (i < 144) k = 4;
		else if (i < 768) k = 5;
		else k = 6;
		if (i < 8) z = new Classic(m);
		else if (m.isEven()) z = new Barrett(m);
		else z = new Montgomery(m);
		var g = new Array(),
			n = 3,
			k1 = k - 1,
			km = (1 << k) - 1;
		g[1] = z.convert(this);
		if (k > 1) {
			var g2 = nbi();
			z.sqrTo(g[1], g2);
			while (n <= km) {
				g[n] = nbi();
				z.mulTo(g2, g[n - 2], g[n]);
				n += 2;
			}
		}
		var j = e.t - 1,
			w, is1 = true,
			r2 = nbi(),
			t;
		i = nbits(e[j]) - 1;
		while (j >= 0) {
			if (i >= k1) w = (e[j] >> (i - k1)) & km;
			else {
				w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
				if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
			}
			n = k;
			while ((w & 1) == 0) {
				w >>= 1;
				--n;
			}
			if ((i -= n) < 0) {
				i += this.DB;
				--j;
			}
			if (is1) {
				g[w].copyTo(r);
				is1 = false;
			} else {
				while (n > 1) {
					z.sqrTo(r, r2);
					z.sqrTo(r2, r);
					n -= 2;
				}
				if (n > 0) z.sqrTo(r, r2);
				else {
					t = r;
					r = r2;
					r2 = t;
				}
				z.mulTo(r2, g[w], r);
			}
			while (j >= 0 && (e[j] & (1 << i)) == 0) {
				z.sqrTo(r, r2);
				t = r;
				r = r2;
				r2 = t;
				if (--i < 0) {
					i = this.DB - 1;
					--j;
				}
			}
		}
		return z.revert(r);
	};

	function bnGCD(a) {
		var x = (this.s < 0) ? this.negate() : this.clone();
		var y = (a.s < 0) ? a.negate() : a.clone();
		if (x.compareTo(y) < 0) {
			var t = x;
			x = y;
			y = t;
		}
		var i = x.getLowestSetBit(),
			g = y.getLowestSetBit();
		if (g < 0) return x;
		if (i < g) g = i;
		if (g > 0) {
			x.rShiftTo(g, x);
			y.rShiftTo(g, y);
		}
		while (x.signum() > 0) {
			if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
			if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
			if (x.compareTo(y) >= 0) {
				x.subTo(y, x);
				x.rShiftTo(1, x);
			} else {
				y.subTo(x, y);
				y.rShiftTo(1, y);
			}
		}
		if (g > 0) y.lShiftTo(g, y);
		return y;
	};

	function bnpModInt(n) {
		if (n <= 0) return 0;
		var d = this.DV % n,
			r = (this.s < 0) ? n - 1 : 0;
		if (this.t > 0) if (d == 0) r = this[0] % n;
		else for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
		return r;
	};

	function bnModInverse(m) {
		var ac = m.isEven();
		if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
		var u = m.clone(),
			v = this.clone();
		var a = nbv(1),
			b = nbv(0),
			c = nbv(0),
			d = nbv(1);
		while (u.signum() != 0) {
			while (u.isEven()) {
				u.rShiftTo(1, u);
				if (ac) {
					if (!a.isEven() || !b.isEven()) {
						a.addTo(this, a);
						b.subTo(m, b);
					}
					a.rShiftTo(1, a);
				} else if (!b.isEven()) b.subTo(m, b);
				b.rShiftTo(1, b);
			}
			while (v.isEven()) {
				v.rShiftTo(1, v);
				if (ac) {
					if (!c.isEven() || !d.isEven()) {
						c.addTo(this, c);
						d.subTo(m, d);
					}
					c.rShiftTo(1, c);
				} else if (!d.isEven()) d.subTo(m, d);
				d.rShiftTo(1, d);
			}
			if (u.compareTo(v) >= 0) {
				u.subTo(v, u);
				if (ac) a.subTo(c, a);
				b.subTo(d, b);
			} else {
				v.subTo(u, v);
				if (ac) c.subTo(a, c);
				d.subTo(b, d);
			}
		}
		if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
		if (d.compareTo(m) >= 0) return d.subtract(m);
		if (d.signum() < 0) d.addTo(m, d);
		else return d;
		if (d.signum() < 0) return d.add(m);
		else return d;
	};
	var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
	var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

	function bnIsProbablePrime(t) {
		var i, x = this.abs();
		if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
			for (i = 0; i < lowprimes.length; ++i) if (x[0] == lowprimes[i]) return true;
			return false;
		}
		if (x.isEven()) return false;
		i = 1;
		while (i < lowprimes.length) {
			var m = lowprimes[i],
				j = i + 1;
			while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
			m = x.modInt(m);
			while (i < j) if (m % lowprimes[i++] == 0) return false;
		}
		return x.millerRabin(t);
	};

	function bnpMillerRabin(t) {
		var n1 = this.subtract(BigInteger.ONE);
		var k = n1.getLowestSetBit();
		if (k <= 0) return false;
		var r = n1.shiftRight(k);
		t = (t + 1) >> 1;
		if (t > lowprimes.length) t = lowprimes.length;
		var a = nbi();
		for (var i = 0; i < t; ++i) {
			a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
			var y = a.modPow(r, this);
			if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
				var j = 1;
				while (j++ < k && y.compareTo(n1) != 0) {
					y = y.modPowInt(2, this);
					if (y.compareTo(BigInteger.ONE) == 0) return false;
				}
				if (y.compareTo(n1) != 0) return false;
			}
		}
		return true;
	};
	BigInteger.prototype.chunkSize = bnpChunkSize;
	BigInteger.prototype.toRadix = bnpToRadix;
	BigInteger.prototype.fromRadix = bnpFromRadix;
	BigInteger.prototype.fromNumber = bnpFromNumber;
	BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
	BigInteger.prototype.changeBit = bnpChangeBit;
	BigInteger.prototype.addTo = bnpAddTo;
	BigInteger.prototype.dMultiply = bnpDMultiply;
	BigInteger.prototype.dAddOffset = bnpDAddOffset;
	BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
	BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
	BigInteger.prototype.modInt = bnpModInt;
	BigInteger.prototype.millerRabin = bnpMillerRabin;
	BigInteger.prototype.clone = bnClone;
	BigInteger.prototype.intValue = bnIntValue;
	BigInteger.prototype.byteValue = bnByteValue;
	BigInteger.prototype.shortValue = bnShortValue;
	BigInteger.prototype.signum = bnSigNum;
	BigInteger.prototype.toByteArray = bnToByteArray;
	BigInteger.prototype.equals = bnEquals;
	BigInteger.prototype.min = bnMin;
	BigInteger.prototype.max = bnMax;
	BigInteger.prototype.and = bnAnd;
	BigInteger.prototype.or = bnOr;
	BigInteger.prototype.xor = bnXor;
	BigInteger.prototype.andNot = bnAndNot;
	BigInteger.prototype.not = bnNot;
	BigInteger.prototype.shiftLeft = bnShiftLeft;
	BigInteger.prototype.shiftRight = bnShiftRight;
	BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
	BigInteger.prototype.bitCount = bnBitCount;
	BigInteger.prototype.testBit = bnTestBit;
	BigInteger.prototype.setBit = bnSetBit;
	BigInteger.prototype.clearBit = bnClearBit;
	BigInteger.prototype.flipBit = bnFlipBit;
	BigInteger.prototype.add = bnAdd;
	BigInteger.prototype.subtract = bnSubtract;
	BigInteger.prototype.multiply = bnMultiply;
	BigInteger.prototype.divide = bnDivide;
	BigInteger.prototype.remainder = bnRemainder;
	BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
	BigInteger.prototype.modPow = bnModPow;
	BigInteger.prototype.modInverse = bnModInverse;
	BigInteger.prototype.pow = bnPow;
	BigInteger.prototype.gcd = bnGCD;
	BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
	BigInteger.prototype.square = bnSquare;

	function Arcfour() {
		this.i = 0;
		this.j = 0;
		this.S = new Array();
	};

	function ARC4init(key) {
		var i, j, t;
		for (i = 0; i < 256; ++i) this.S[i] = i;
		j = 0;
		for (i = 0; i < 256; ++i) {
			j = (j + this.S[i] + key[i % key.length]) & 255;
			t = this.S[i];
			this.S[i] = this.S[j];
			this.S[j] = t;
		}
		this.i = 0;
		this.j = 0;
	};

	function ARC4next() {
		var t;
		this.i = (this.i + 1) & 255;
		this.j = (this.j + this.S[this.i]) & 255;
		t = this.S[this.i];
		this.S[this.i] = this.S[this.j];
		this.S[this.j] = t;
		return this.S[(t + this.S[this.i]) & 255];
	};
	Arcfour.prototype.init = ARC4init;
	Arcfour.prototype.next = ARC4next;

	function prng_newstate() {
		return new Arcfour();
	};
	var rng_psize = 256;
	var rng_state;
	var rng_pool;
	var rng_pptr;
	if (rng_pool == null) {
		rng_pool = new Array();
		rng_pptr = 0;
		var t;
		if (window.crypto && window.crypto.getRandomValues) {
			var z = new Uint32Array(256);
			window.crypto.getRandomValues(z);
			for (t = 0; t < z.length; ++t) rng_pool[rng_pptr++] = z[t] & 255;
		}
		var onMouseMoveListener = function(ev) {
				this.count = this.count || 0;
				if (this.count >= 256 || rng_pptr >= rng_psize) {
					if (window.removeEventListener) window.removeEventListener("mousemove", onMouseMoveListener);
					else if (window.detachEvent) window.detachEvent("onmousemove", onMouseMoveListener);
					return;
				}
				this.count += 1;
				var mouseCoordinates = ev.x + ev.y;
				rng_pool[rng_pptr++] = mouseCoordinates & 255;
			};
		if (window.addEventListener) window.addEventListener("mousemove", onMouseMoveListener);
		else if (window.attachEvent) window.attachEvent("onmousemove", onMouseMoveListener);
	}
	function rng_get_byte() {
		if (rng_state == null) {
			rng_state = prng_newstate();
			while (rng_pptr < rng_psize) {
				var random = Math.floor(65536 * Math.random());
				rng_pool[rng_pptr++] = random & 255;
			}
			rng_state.init(rng_pool);
			for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) rng_pool[rng_pptr] = 0;
			rng_pptr = 0;
		}
		return rng_state.next();
	};

	function rng_get_bytes(ba) {
		var i;
		for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
	};

	function SecureRandom() {};
	SecureRandom.prototype.nextBytes = rng_get_bytes;

	function parseBigInt(str, r) {
		return new BigInteger(str, r);
	};

	function linebrk(s, n) {
		var ret = "";
		var i = 0;
		while (i + n < s.length) {
			ret += s.substring(i, i + n) + "\n";
			i += n;
		}
		return ret + s.substring(i, s.length);
	};

	function byte2Hex(b) {
		if (b < 0x10) return "0" + b.toString(16);
		else return b.toString(16);
	};

	function pkcs1pad2(s, n) {
		if (n < s.length + 11) {
			console.error("Message too long for RSA");
			return null;
		}
		var ba = new Array();
		var i = s.length - 1;
		while (i >= 0 && n > 0) {
			var c = s.charCodeAt(i--);
			if (c < 128) {
				ba[--n] = c;
			} else if ((c > 127) && (c < 2048)) {
				ba[--n] = (c & 63) | 128;
				ba[--n] = (c >> 6) | 192;
			} else {
				ba[--n] = (c & 63) | 128;
				ba[--n] = ((c >> 6) & 63) | 128;
				ba[--n] = (c >> 12) | 224;
			}
		}
		ba[--n] = 0;
		var rng = new SecureRandom();
		var x = new Array();
		while (n > 2) {
			x[0] = 0;
			while (x[0] == 0) rng.nextBytes(x);
			ba[--n] = x[0];
		}
		ba[--n] = 2;
		ba[--n] = 0;
		return new BigInteger(ba);
	};

	function RSAKey() {
		this.n = null;
		this.e = 0;
		this.d = null;
		this.p = null;
		this.q = null;
		this.dmp1 = null;
		this.dmq1 = null;
		this.coeff = null;
	};

	function RSASetPublic(N, E) {
		if (N != null && E != null && N.length > 0 && E.length > 0) {
			this.n = parseBigInt(N, 16);
			this.e = parseInt(E, 16);
		} else console.error("Invalid RSA public key");
	};

	function RSADoPublic(x) {
		return x.modPowInt(this.e, this.n);
	};

	function RSAEncrypt(text) {
		var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
		if (m == null) return null;
		var c = this.doPublic(m);
		if (c == null) return null;
		var h = c.toString(16);
		if ((h.length & 1) == 0) return h;
		else return "0" + h;
	};
	RSAKey.prototype.doPublic = RSADoPublic;
	RSAKey.prototype.setPublic = RSASetPublic;
	RSAKey.prototype.encrypt = RSAEncrypt;

	function pkcs1unpad2(d, n) {
		var b = d.toByteArray();
		var i = 0;
		while (i < b.length && b[i] == 0)++i;
		if (b.length - i != n - 1 || b[i] != 2) return null;
		++i;
		while (b[i] != 0) if (++i >= b.length) return null;
		var ret = "";
		while (++i < b.length) {
			var c = b[i] & 255;
			if (c < 128) {
				ret += String.fromCharCode(c);
			} else if ((c > 191) && (c < 224)) {
				ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
				++i;
			} else {
				ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
				i += 2;
			}
		}
		return ret;
	};

	function RSASetPrivate(N, E, D) {
		if (N != null && E != null && N.length > 0 && E.length > 0) {
			this.n = parseBigInt(N, 16);
			this.e = parseInt(E, 16);
			this.d = parseBigInt(D, 16);
		} else console.error("Invalid RSA private key");
	};

	function RSASetPrivateEx(N, E, D, P, Q, DP, DQ, C) {
		if (N != null && E != null && N.length > 0 && E.length > 0) {
			this.n = parseBigInt(N, 16);
			this.e = parseInt(E, 16);
			this.d = parseBigInt(D, 16);
			this.p = parseBigInt(P, 16);
			this.q = parseBigInt(Q, 16);
			this.dmp1 = parseBigInt(DP, 16);
			this.dmq1 = parseBigInt(DQ, 16);
			this.coeff = parseBigInt(C, 16);
		} else console.error("Invalid RSA private key");
	};

	function RSAGenerate(B, E) {
		var rng = new SecureRandom();
		var qs = B >> 1;
		this.e = parseInt(E, 16);
		var ee = new BigInteger(E, 16);
		for (;;) {
			for (;;) {
				this.p = new BigInteger(B - qs, 1, rng);
				if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.p.isProbablePrime(10)) break;
			}
			for (;;) {
				this.q = new BigInteger(qs, 1, rng);
				if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 && this.q.isProbablePrime(10)) break;
			}
			if (this.p.compareTo(this.q) <= 0) {
				var t = this.p;
				this.p = this.q;
				this.q = t;
			}
			var p1 = this.p.subtract(BigInteger.ONE);
			var q1 = this.q.subtract(BigInteger.ONE);
			var phi = p1.multiply(q1);
			if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
				this.n = this.p.multiply(this.q);
				this.d = ee.modInverse(phi);
				this.dmp1 = this.d.mod(p1);
				this.dmq1 = this.d.mod(q1);
				this.coeff = this.q.modInverse(this.p);
				break;
			}
		}
	};

	function RSADoPrivate(x) {
		if (this.p == null || this.q == null) return x.modPow(this.d, this.n);
		var xp = x.mod(this.p).modPow(this.dmp1, this.p);
		var xq = x.mod(this.q).modPow(this.dmq1, this.q);
		while (xp.compareTo(xq) < 0) xp = xp.add(this.p);
		return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
	};

	function RSADecrypt(ctext) {
		var c = parseBigInt(ctext, 16);
		var m = this.doPrivate(c);
		if (m == null) return null;
		return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
	};
	RSAKey.prototype.doPrivate = RSADoPrivate;
	RSAKey.prototype.setPrivate = RSASetPrivate;
	RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
	RSAKey.prototype.generate = RSAGenerate;
	RSAKey.prototype.decrypt = RSADecrypt;
	(function() {
		var RSAGenerateAsync = function(B, E, callback) {
				var rng = new SecureRandom();
				var qs = B >> 1;
				this.e = parseInt(E, 16);
				var ee = new BigInteger(E, 16);
				var rsa = this;
				var loop1 = function() {
						var loop4 = function() {
								if (rsa.p.compareTo(rsa.q) <= 0) {
									var t = rsa.p;
									rsa.p = rsa.q;
									rsa.q = t;
								}
								var p1 = rsa.p.subtract(BigInteger.ONE);
								var q1 = rsa.q.subtract(BigInteger.ONE);
								var phi = p1.multiply(q1);
								if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
									rsa.n = rsa.p.multiply(rsa.q);
									rsa.d = ee.modInverse(phi);
									rsa.dmp1 = rsa.d.mod(p1);
									rsa.dmq1 = rsa.d.mod(q1);
									rsa.coeff = rsa.q.modInverse(rsa.p);
									setTimeout(function() {
										callback()
									}, 0);
								} else {
									setTimeout(loop1, 0);
								}
							};
						var loop3 = function() {
								rsa.q = nbi();
								rsa.q.fromNumberAsync(qs, 1, rng, function() {
									rsa.q.subtract(BigInteger.ONE).gcda(ee, function(r) {
										if (r.compareTo(BigInteger.ONE) == 0 && rsa.q.isProbablePrime(10)) {
											setTimeout(loop4, 0);
										} else {
											setTimeout(loop3, 0);
										}
									});
								});
							};
						var loop2 = function() {
								rsa.p = nbi();
								rsa.p.fromNumberAsync(B - qs, 1, rng, function() {
									rsa.p.subtract(BigInteger.ONE).gcda(ee, function(r) {
										if (r.compareTo(BigInteger.ONE) == 0 && rsa.p.isProbablePrime(10)) {
											setTimeout(loop3, 0);
										} else {
											setTimeout(loop2, 0);
										}
									});
								});
							};
						setTimeout(loop2, 0);
					};
				setTimeout(loop1, 0);
			};
		RSAKey.prototype.generateAsync = RSAGenerateAsync;
		var bnGCDAsync = function(a, callback) {
				var x = (this.s < 0) ? this.negate() : this.clone();
				var y = (a.s < 0) ? a.negate() : a.clone();
				if (x.compareTo(y) < 0) {
					var t = x;
					x = y;
					y = t;
				}
				var i = x.getLowestSetBit(),
					g = y.getLowestSetBit();
				if (g < 0) {
					callback(x);
					return;
				}
				if (i < g) g = i;
				if (g > 0) {
					x.rShiftTo(g, x);
					y.rShiftTo(g, y);
				}
				var gcda1 = function() {
						if ((i = x.getLowestSetBit()) > 0) {
							x.rShiftTo(i, x);
						}
						if ((i = y.getLowestSetBit()) > 0) {
							y.rShiftTo(i, y);
						}
						if (x.compareTo(y) >= 0) {
							x.subTo(y, x);
							x.rShiftTo(1, x);
						} else {
							y.subTo(x, y);
							y.rShiftTo(1, y);
						}
						if (!(x.signum() > 0)) {
							if (g > 0) y.lShiftTo(g, y);
							setTimeout(function() {
								callback(y)
							}, 0);
						} else {
							setTimeout(gcda1, 0);
						}
					};
				setTimeout(gcda1, 10);
			};
		BigInteger.prototype.gcda = bnGCDAsync;
		var bnpFromNumberAsync = function(a, b, c, callback) {
				if ("number" == typeof b) {
					if (a < 2) {
						this.fromInt(1);
					} else {
						this.fromNumber(a, c);
						if (!this.testBit(a - 1)) {
							this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
						}
						if (this.isEven()) {
							this.dAddOffset(1, 0);
						}
						var bnp = this;
						var bnpfn1 = function() {
								bnp.dAddOffset(2, 0);
								if (bnp.bitLength() > a) bnp.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp);
								if (bnp.isProbablePrime(b)) {
									setTimeout(function() {
										callback()
									}, 0);
								} else {
									setTimeout(bnpfn1, 0);
								}
							};
						setTimeout(bnpfn1, 0);
					}
				} else {
					var x = new Array(),
						t = a & 7;
					x.length = (a >> 3) + 1;
					b.nextBytes(x);
					if (t > 0) x[0] &= ((1 << t) - 1);
					else x[0] = 0;
					this.fromString(x, 256);
				}
			};
		BigInteger.prototype.fromNumberAsync = bnpFromNumberAsync;
	})();
	var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	var b64pad = "=";

	function hex2b64(h) {
		var i;
		var c;
		var ret = "";
		for (i = 0; i + 3 <= h.length; i += 3) {
			c = parseInt(h.substring(i, i + 3), 16);
			ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
		}
		if (i + 1 == h.length) {
			c = parseInt(h.substring(i, i + 1), 16);
			ret += b64map.charAt(c << 2);
		} else if (i + 2 == h.length) {
			c = parseInt(h.substring(i, i + 2), 16);
			ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
		}
		while ((ret.length & 3) > 0) ret += b64pad;
		return ret;
	};

	function b64tohex(s) {
		var ret = "";
		var i;
		var k = 0;
		var slop;
		for (i = 0; i < s.length; ++i) {
			if (s.charAt(i) == b64pad) break;
			v = b64map.indexOf(s.charAt(i));
			if (v < 0) continue;
			if (k == 0) {
				ret += int2char(v >> 2);
				slop = v & 3;
				k = 1;
			} else if (k == 1) {
				ret += int2char((slop << 2) | (v >> 4));
				slop = v & 0xf;
				k = 2;
			} else if (k == 2) {
				ret += int2char(slop);
				ret += int2char(v >> 2);
				slop = v & 3;
				k = 3;
			} else {
				ret += int2char((slop << 2) | (v >> 4));
				ret += int2char(v & 0xf);
				k = 0;
			}
		}
		if (k == 1) ret += int2char(slop << 2);
		return ret;
	};

	function b64toBA(s) {
		var h = b64tohex(s);
		var i;
		var a = new Array();
		for (i = 0; 2 * i < h.length; ++i) {
			a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);
		}
		return a;
	};
	var JSX = JSX || {};
	JSX.env = JSX.env || {};
	var L = JSX,
		OP = Object.prototype,
		FUNCTION_TOSTRING = '[object Function]',
		ADD = ["toString", "valueOf"];
	JSX.env.parseUA = function(agent) {
		var numberify = function(s) {
				var c = 0;
				return parseFloat(s.replace(/\./g, function() {
					return (c++ == 1) ? '' : '.';
				}));
			},
			nav = navigator,
			o = {
				ie: 0,
				opera: 0,
				gecko: 0,
				webkit: 0,
				chrome: 0,
				mobile: null,
				air: 0,
				ipad: 0,
				iphone: 0,
				ipod: 0,
				ios: null,
				android: 0,
				webos: 0,
				caja: nav && nav.cajaVersion,
				secure: false,
				os: null
			},
			ua = agent || (navigator && navigator.userAgent),
			loc = window && window.location,
			href = loc && loc.href,
			m;
		o.secure = href && (href.toLowerCase().indexOf("https") === 0);
		if (ua) {
			if ((/windows|win32/i).test(ua)) {
				o.os = 'windows';
			} else if ((/macintosh/i).test(ua)) {
				o.os = 'macintosh';
			} else if ((/rhino/i).test(ua)) {
				o.os = 'rhino';
			}
			if ((/KHTML/).test(ua)) {
				o.webkit = 1;
			}
			m = ua.match(/AppleWebKit\/([^\s]*)/);
			if (m && m[1]) {
				o.webkit = numberify(m[1]);
				if (/ Mobile\//.test(ua)) {
					o.mobile = 'Apple';
					m = ua.match(/OS ([^\s]*)/);
					if (m && m[1]) {
						m = numberify(m[1].replace('_', '.'));
					}
					o.ios = m;
					o.ipad = o.ipod = o.iphone = 0;
					m = ua.match(/iPad|iPod|iPhone/);
					if (m && m[0]) {
						o[m[0].toLowerCase()] = o.ios;
					}
				} else {
					m = ua.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);
					if (m) {
						o.mobile = m[0];
					}
					if (/webOS/.test(ua)) {
						o.mobile = 'WebOS';
						m = ua.match(/webOS\/([^\s]*);/);
						if (m && m[1]) {
							o.webos = numberify(m[1]);
						}
					}
					if (/ Android/.test(ua)) {
						o.mobile = 'Android';
						m = ua.match(/Android ([^\s]*);/);
						if (m && m[1]) {
							o.android = numberify(m[1]);
						}
					}
				}
				m = ua.match(/Chrome\/([^\s]*)/);
				if (m && m[1]) {
					o.chrome = numberify(m[1]);
				} else {
					m = ua.match(/AdobeAIR\/([^\s]*)/);
					if (m) {
						o.air = m[0];
					}
				}
			}
			if (!o.webkit) {
				m = ua.match(/Opera[\s\/]([^\s]*)/);
				if (m && m[1]) {
					o.opera = numberify(m[1]);
					m = ua.match(/Version\/([^\s]*)/);
					if (m && m[1]) {
						o.opera = numberify(m[1]);
					}
					m = ua.match(/Opera Mini[^;]*/);
					if (m) {
						o.mobile = m[0];
					}
				} else {
					m = ua.match(/MSIE\s([^;]*)/);
					if (m && m[1]) {
						o.ie = numberify(m[1]);
					} else {
						m = ua.match(/Gecko\/([^\s]*)/);
						if (m) {
							o.gecko = 1;
							m = ua.match(/rv:([^\s\)]*)/);
							if (m && m[1]) {
								o.gecko = numberify(m[1]);
							}
						}
					}
				}
			}
		}
		return o;
	};
	JSX.env.ua = JSX.env.parseUA();
	JSX.isFunction = function(o) {
		return (typeof o === 'function') || OP.toString.apply(o) === FUNCTION_TOSTRING;
	};
	JSX._IEEnumFix = (JSX.env.ua.ie) ?
	function(r, s) {
		var i, fname, f;
		for (i = 0; i < ADD.length; i = i + 1) {
			fname = ADD[i];
			f = s[fname];
			if (L.isFunction(f) && f != OP[fname]) {
				r[fname] = f;
			}
		}
	} : function() {};
	JSX.extend = function(subc, superc, overrides) {
		if (!superc || !subc) {
			throw new Error("extend failed, please check that " + "all dependencies are included.");
		}
		var F = function() {},
			i;
		F.prototype = superc.prototype;
		subc.prototype = new F();
		subc.prototype.constructor = subc;
		subc.superclass = superc.prototype;
		if (superc.prototype.constructor == OP.constructor) {
			superc.prototype.constructor = superc;
		}
		if (overrides) {
			for (i in overrides) {
				if (L.hasOwnProperty(overrides, i)) {
					subc.prototype[i] = overrides[i];
				}
			}
			L._IEEnumFix(subc.prototype, overrides);
		}
	};
	if (typeof KJUR == "undefined" || !KJUR) KJUR = {};
	if (typeof KJUR.asn1 == "undefined" || !KJUR.asn1) KJUR.asn1 = {};
	KJUR.asn1.ASN1Util = new function() {
		this.integerToByteHex = function(i) {
			var h = i.toString(16);
			if ((h.length % 2) == 1) h = '0' + h;
			return h;
		};
		this.bigIntToMinTwosComplementsHex = function(bigIntegerValue) {
			var h = bigIntegerValue.toString(16);
			if (h.substr(0, 1) != '-') {
				if (h.length % 2 == 1) {
					h = '0' + h;
				} else {
					if (!h.match(/^[0-7]/)) {
						h = '00' + h;
					}
				}
			} else {
				var hPos = h.substr(1);
				var xorLen = hPos.length;
				if (xorLen % 2 == 1) {
					xorLen += 1;
				} else {
					if (!h.match(/^[0-7]/)) {
						xorLen += 2;
					}
				}
				var hMask = '';
				for (var i = 0; i < xorLen; i++) {
					hMask += 'f';
				}
				var biMask = new BigInteger(hMask, 16);
				var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
				h = biNeg.toString(16).replace(/^-/, '');
			}
			return h;
		};
		this.getPEMStringFromHex = function(dataHex, pemHeader) {
			var dataWA = CryptoJS.enc.Hex.parse(dataHex);
			var dataB64 = CryptoJS.enc.Base64.stringify(dataWA);
			var pemBody = dataB64.replace(/(.{64})/g, "$1\r\n");
			pemBody = pemBody.replace(/\r\n$/, '');
			return "-----BEGIN " + pemHeader + "-----\r\n" + pemBody + "\r\n-----END " + pemHeader + "-----\r\n";
		};
	};
	KJUR.asn1.ASN1Object = function() {
		var isModified = true;
		var hTLV = null;
		var hT = '00';
		var hL = '00';
		var hV = '';
		this.getLengthHexFromValue = function() {
			if (typeof this.hV == "undefined" || this.hV == null) {
				throw "this.hV is null or undefined.";
			}
			if (this.hV.length % 2 == 1) {
				throw "value hex must be even length: n=" + hV.length + ",v=" + this.hV;
			}
			var n = this.hV.length / 2;
			var hN = n.toString(16);
			if (hN.length % 2 == 1) {
				hN = "0" + hN;
			}
			if (n < 128) {
				return hN;
			} else {
				var hNlen = hN.length / 2;
				if (hNlen > 15) {
					throw "ASN.1 length too long to represent by 8x: n = " + n.toString(16);
				}
				var head = 128 + hNlen;
				return head.toString(16) + hN;
			}
		};
		this.getEncodedHex = function() {
			if (this.hTLV == null || this.isModified) {
				this.hV = this.getFreshValueHex();
				this.hL = this.getLengthHexFromValue();
				this.hTLV = this.hT + this.hL + this.hV;
				this.isModified = false;
			}
			return this.hTLV;
		};
		this.getValueHex = function() {
			this.getEncodedHex();
			return this.hV;
		};
		this.getFreshValueHex = function() {
			return '';
		};
	};
	KJUR.asn1.DERAbstractString = function(params) {
		KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
		var s = null;
		var hV = null;
		this.getString = function() {
			return this.s;
		};
		this.setString = function(newS) {
			this.hTLV = null;
			this.isModified = true;
			this.s = newS;
			this.hV = stohex(this.s);
		};
		this.setStringHex = function(newHexString) {
			this.hTLV = null;
			this.isModified = true;
			this.s = null;
			this.hV = newHexString;
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
		if (typeof params != "undefined") {
			if (typeof params['str'] != "undefined") {
				this.setString(params['str']);
			} else if (typeof params['hex'] != "undefined") {
				this.setStringHex(params['hex']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERAbstractTime = function(params) {
		KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
		var s = null;
		var date = null;
		this.localDateToUTC = function(d) {
			utc = d.getTime() + (d.getTimezoneOffset() * 60000);
			var utcDate = new Date(utc);
			return utcDate;
		};
		this.formatDate = function(dateObject, type) {
			var pad = this.zeroPadding;
			var d = this.localDateToUTC(dateObject);
			var year = String(d.getFullYear());
			if (type == 'utc') year = year.substr(2, 2);
			var month = pad(String(d.getMonth() + 1), 2);
			var day = pad(String(d.getDate()), 2);
			var hour = pad(String(d.getHours()), 2);
			var min = pad(String(d.getMinutes()), 2);
			var sec = pad(String(d.getSeconds()), 2);
			return year + month + day + hour + min + sec + 'Z';
		};
		this.zeroPadding = function(s, len) {
			if (s.length >= len) return s;
			return new Array(len - s.length + 1).join('0') + s;
		};
		this.getString = function() {
			return this.s;
		};
		this.setString = function(newS) {
			this.hTLV = null;
			this.isModified = true;
			this.s = newS;
			this.hV = stohex(this.s);
		};
		this.setByDateValue = function(year, month, day, hour, min, sec) {
			var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
			this.setByDate(dateObject);
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
	};
	JSX.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERAbstractStructured = function(params) {
		KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
		var asn1Array = null;
		this.setByASN1ObjectArray = function(asn1ObjectArray) {
			this.hTLV = null;
			this.isModified = true;
			this.asn1Array = asn1ObjectArray;
		};
		this.appendASN1Object = function(asn1Object) {
			this.hTLV = null;
			this.isModified = true;
			this.asn1Array.push(asn1Object);
		};
		this.asn1Array = new Array();
		if (typeof params != "undefined") {
			if (typeof params['array'] != "undefined") {
				this.asn1Array = params['array'];
			}
		}
	};
	JSX.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERBoolean = function() {
		KJUR.asn1.DERBoolean.superclass.constructor.call(this);
		this.hT = "01";
		this.hTLV = "0101ff";
	};
	JSX.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERInteger = function(params) {
		KJUR.asn1.DERInteger.superclass.constructor.call(this);
		this.hT = "02";
		this.setByBigInteger = function(bigIntegerValue) {
			this.hTLV = null;
			this.isModified = true;
			this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
		};
		this.setByInteger = function(intValue) {
			var bi = new BigInteger(String(intValue), 10);
			this.setByBigInteger(bi);
		};
		this.setValueHex = function(newHexString) {
			this.hV = newHexString;
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
		if (typeof params != "undefined") {
			if (typeof params['bigint'] != "undefined") {
				this.setByBigInteger(params['bigint']);
			} else if (typeof params['int'] != "undefined") {
				this.setByInteger(params['int']);
			} else if (typeof params['hex'] != "undefined") {
				this.setValueHex(params['hex']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERBitString = function(params) {
		KJUR.asn1.DERBitString.superclass.constructor.call(this);
		this.hT = "03";
		this.setHexValueIncludingUnusedBits = function(newHexStringIncludingUnusedBits) {
			this.hTLV = null;
			this.isModified = true;
			this.hV = newHexStringIncludingUnusedBits;
		};
		this.setUnusedBitsAndHexValue = function(unusedBits, hValue) {
			if (unusedBits < 0 || 7 < unusedBits) {
				throw "unused bits shall be from 0 to 7: u = " + unusedBits;
			}
			var hUnusedBits = "0" + unusedBits;
			this.hTLV = null;
			this.isModified = true;
			this.hV = hUnusedBits + hValue;
		};
		this.setByBinaryString = function(binaryString) {
			binaryString = binaryString.replace(/0+$/, '');
			var unusedBits = 8 - binaryString.length % 8;
			if (unusedBits == 8) unusedBits = 0;
			for (var i = 0; i <= unusedBits; i++) {
				binaryString += '0';
			}
			var h = '';
			for (var i = 0; i < binaryString.length - 1; i += 8) {
				var b = binaryString.substr(i, 8);
				var x = parseInt(b, 2).toString(16);
				if (x.length == 1) x = '0' + x;
				h += x;
			}
			this.hTLV = null;
			this.isModified = true;
			this.hV = '0' + unusedBits + h;
		};
		this.setByBooleanArray = function(booleanArray) {
			var s = '';
			for (var i = 0; i < booleanArray.length; i++) {
				if (booleanArray[i] == true) {
					s += '1';
				} else {
					s += '0';
				}
			}
			this.setByBinaryString(s);
		};
		this.newFalseArray = function(nLength) {
			var a = new Array(nLength);
			for (var i = 0; i < nLength; i++) {
				a[i] = false;
			}
			return a;
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
		if (typeof params != "undefined") {
			if (typeof params['hex'] != "undefined") {
				this.setHexValueIncludingUnusedBits(params['hex']);
			} else if (typeof params['bin'] != "undefined") {
				this.setByBinaryString(params['bin']);
			} else if (typeof params['array'] != "undefined") {
				this.setByBooleanArray(params['array']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
	KJUR.asn1.DEROctetString = function(params) {
		KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
		this.hT = "04";
	};
	JSX.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERNull = function() {
		KJUR.asn1.DERNull.superclass.constructor.call(this);
		this.hT = "05";
		this.hTLV = "0500";
	};
	JSX.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERObjectIdentifier = function(params) {
		var itox = function(i) {
				var h = i.toString(16);
				if (h.length == 1) h = '0' + h;
				return h;
			};
		var roidtox = function(roid) {
				var h = '';
				var bi = new BigInteger(roid, 10);
				var b = bi.toString(2);
				var padLen = 7 - b.length % 7;
				if (padLen == 7) padLen = 0;
				var bPad = '';
				for (var i = 0; i < padLen; i++) bPad += '0';
				b = bPad + b;
				for (var i = 0; i < b.length - 1; i += 7) {
					var b8 = b.substr(i, 7);
					if (i != b.length - 7) b8 = '1' + b8;
					h += itox(parseInt(b8, 2));
				}
				return h;
			};
		KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
		this.hT = "06";
		this.setValueHex = function(newHexString) {
			this.hTLV = null;
			this.isModified = true;
			this.s = null;
			this.hV = newHexString;
		};
		this.setValueOidString = function(oidString) {
			if (!oidString.match(/^[0-9.]+$/)) {
				throw "malformed oid string: " + oidString;
			}
			var h = '';
			var a = oidString.split('.');
			var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
			h += itox(i0);
			a.splice(0, 2);
			for (var i = 0; i < a.length; i++) {
				h += roidtox(a[i]);
			}
			this.hTLV = null;
			this.isModified = true;
			this.s = null;
			this.hV = h;
		};
		this.setValueName = function(oidName) {
			if (typeof KJUR.asn1.x509.OID.name2oidList[oidName] != "undefined") {
				var oid = KJUR.asn1.x509.OID.name2oidList[oidName];
				this.setValueOidString(oid);
			} else {
				throw "DERObjectIdentifier oidName undefined: " + oidName;
			}
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
		if (typeof params != "undefined") {
			if (typeof params['oid'] != "undefined") {
				this.setValueOidString(params['oid']);
			} else if (typeof params['hex'] != "undefined") {
				this.setValueHex(params['hex']);
			} else if (typeof params['name'] != "undefined") {
				this.setValueName(params['name']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
	KJUR.asn1.DERUTF8String = function(params) {
		KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
		this.hT = "0c";
	};
	JSX.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERNumericString = function(params) {
		KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
		this.hT = "12";
	};
	JSX.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERPrintableString = function(params) {
		KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
		this.hT = "13";
	};
	JSX.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERTeletexString = function(params) {
		KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
		this.hT = "14";
	};
	JSX.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERIA5String = function(params) {
		KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
		this.hT = "16";
	};
	JSX.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
	KJUR.asn1.DERUTCTime = function(params) {
		KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
		this.hT = "17";
		this.setByDate = function(dateObject) {
			this.hTLV = null;
			this.isModified = true;
			this.date = dateObject;
			this.s = this.formatDate(this.date, 'utc');
			this.hV = stohex(this.s);
		};
		if (typeof params != "undefined") {
			if (typeof params['str'] != "undefined") {
				this.setString(params['str']);
			} else if (typeof params['hex'] != "undefined") {
				this.setStringHex(params['hex']);
			} else if (typeof params['date'] != "undefined") {
				this.setByDate(params['date']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
	KJUR.asn1.DERGeneralizedTime = function(params) {
		KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
		this.hT = "18";
		this.setByDate = function(dateObject) {
			this.hTLV = null;
			this.isModified = true;
			this.date = dateObject;
			this.s = this.formatDate(this.date, 'gen');
			this.hV = stohex(this.s);
		};
		if (typeof params != "undefined") {
			if (typeof params['str'] != "undefined") {
				this.setString(params['str']);
			} else if (typeof params['hex'] != "undefined") {
				this.setStringHex(params['hex']);
			} else if (typeof params['date'] != "undefined") {
				this.setByDate(params['date']);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
	KJUR.asn1.DERSequence = function(params) {
		KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
		this.hT = "30";
		this.getFreshValueHex = function() {
			var h = '';
			for (var i = 0; i < this.asn1Array.length; i++) {
				var asn1Obj = this.asn1Array[i];
				h += asn1Obj.getEncodedHex();
			}
			this.hV = h;
			return this.hV;
		};
	};
	JSX.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
	KJUR.asn1.DERSet = function(params) {
		KJUR.asn1.DERSet.superclass.constructor.call(this, params);
		this.hT = "31";
		this.getFreshValueHex = function() {
			var a = new Array();
			for (var i = 0; i < this.asn1Array.length; i++) {
				var asn1Obj = this.asn1Array[i];
				a.push(asn1Obj.getEncodedHex());
			}
			a.sort();
			this.hV = a.join('');
			return this.hV;
		};
	};
	JSX.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
	KJUR.asn1.DERTaggedObject = function(params) {
		KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
		this.hT = "a0";
		this.hV = '';
		this.isExplicit = true;
		this.asn1Object = null;
		this.setASN1Object = function(isExplicitFlag, tagNoHex, asn1Object) {
			this.hT = tagNoHex;
			this.isExplicit = isExplicitFlag;
			this.asn1Object = asn1Object;
			if (this.isExplicit) {
				this.hV = this.asn1Object.getEncodedHex();
				this.hTLV = null;
				this.isModified = true;
			} else {
				this.hV = null;
				this.hTLV = asn1Object.getEncodedHex();
				this.hTLV = this.hTLV.replace(/^../, tagNoHex);
				this.isModified = false;
			}
		};
		this.getFreshValueHex = function() {
			return this.hV;
		};
		if (typeof params != "undefined") {
			if (typeof params['tag'] != "undefined") {
				this.hT = params['tag'];
			}
			if (typeof params['explicit'] != "undefined") {
				this.isExplicit = params['explicit'];
			}
			if (typeof params['obj'] != "undefined") {
				this.asn1Object = params['obj'];
				this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
			}
		}
	};
	JSX.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
	(function(undefined) {
		"use strict";
		var Hex = {},
			decoder;
		Hex.decode = function(a) {
			var i;
			if (decoder === undefined) {
				var hex = "0123456789ABCDEF",
					ignore = " \f\n\r\t\u00A0\u2028\u2029";
				decoder = [];
				for (i = 0; i < 16; ++i) decoder[hex.charAt(i)] = i;
				hex = hex.toLowerCase();
				for (i = 10; i < 16; ++i) decoder[hex.charAt(i)] = i;
				for (i = 0; i < ignore.length; ++i) decoder[ignore.charAt(i)] = -1;
			}
			var out = [],
				bits = 0,
				char_count = 0;
			for (i = 0; i < a.length; ++i) {
				var c = a.charAt(i);
				if (c == '=') break;
				c = decoder[c];
				if (c == -1) continue;
				if (c === undefined) throw 'Illegal character at offset ' + i;
				bits |= c;
				if (++char_count >= 2) {
					out[out.length] = bits;
					bits = 0;
					char_count = 0;
				} else {
					bits <<= 4;
				}
			}
			if (char_count) throw "Hex encoding incomplete: 4 bits missing";
			return out;
		};
		window.Hex = Hex;
	})();
	(function(undefined) {
		"use strict";
		var Base64 = {},
			decoder;
		Base64.decode = function(a) {
			var i;
			if (decoder === undefined) {
				var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
					ignore = "= \f\n\r\t\u00A0\u2028\u2029";
				decoder = [];
				for (i = 0; i < 64; ++i) decoder[b64.charAt(i)] = i;
				for (i = 0; i < ignore.length; ++i) decoder[ignore.charAt(i)] = -1;
			}
			var out = [];
			var bits = 0,
				char_count = 0;
			for (i = 0; i < a.length; ++i) {
				var c = a.charAt(i);
				if (c == '=') break;
				c = decoder[c];
				if (c == -1) continue;
				if (c === undefined) throw 'Illegal character at offset ' + i;
				bits |= c;
				if (++char_count >= 4) {
					out[out.length] = (bits >> 16);
					out[out.length] = (bits >> 8) & 0xFF;
					out[out.length] = bits & 0xFF;
					bits = 0;
					char_count = 0;
				} else {
					bits <<= 6;
				}
			}
			switch (char_count) {
			case 1:
				throw "Base64 encoding incomplete: at least 2 bits missing";
			case 2:
				out[out.length] = (bits >> 10);
				break;
			case 3:
				out[out.length] = (bits >> 16);
				out[out.length] = (bits >> 8) & 0xFF;
				break;
			}
			return out;
		};
		Base64.re = /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/;
		Base64.unarmor = function(a) {
			var m = Base64.re.exec(a);
			if (m) {
				if (m[1]) a = m[1];
				else if (m[2]) a = m[2];
				else throw "RegExp out of sync";
			}
			return Base64.decode(a);
		};
		window.Base64 = Base64;
	})();
	(function(undefined) {
		"use strict";
		var hardLimit = 100,
			ellipsis = "\u2026",
			DOM = {
				tag: function(tagName, className) {
					var t = document.createElement(tagName);
					t.className = className;
					return t;
				},
				text: function(str) {
					return document.createTextNode(str);
				}
			};

		function Stream(enc, pos) {
			if (enc instanceof Stream) {
				this.enc = enc.enc;
				this.pos = enc.pos;
			} else {
				this.enc = enc;
				this.pos = pos;
			}
		};
		Stream.prototype.get = function(pos) {
			if (pos === undefined) pos = this.pos++;
			if (pos >= this.enc.length) throw 'Requesting byte offset ' + pos + ' on a stream of length ' + this.enc.length;
			return this.enc[pos];
		};
		Stream.prototype.hexDigits = "0123456789ABCDEF";
		Stream.prototype.hexByte = function(b) {
			return this.hexDigits.charAt((b >> 4) & 0xF) + this.hexDigits.charAt(b & 0xF);
		};
		Stream.prototype.hexDump = function(start, end, raw) {
			var s = "";
			for (var i = start; i < end; ++i) {
				s += this.hexByte(this.get(i));
				if (raw !== true) switch (i & 0xF) {
				case 0x7:
					s += "  ";
					break;
				case 0xF:
					s += "\n";
					break;
				default:
					s += " ";
				}
			}
			return s;
		};
		Stream.prototype.parseStringISO = function(start, end) {
			var s = "";
			for (var i = start; i < end; ++i) s += String.fromCharCode(this.get(i));
			return s;
		};
		Stream.prototype.parseStringUTF = function(start, end) {
			var s = "";
			for (var i = start; i < end;) {
				var c = this.get(i++);
				if (c < 128) s += String.fromCharCode(c);
				else if ((c > 191) && (c < 224)) s += String.fromCharCode(((c & 0x1F) << 6) | (this.get(i++) & 0x3F));
				else s += String.fromCharCode(((c & 0x0F) << 12) | ((this.get(i++) & 0x3F) << 6) | (this.get(i++) & 0x3F));
			}
			return s;
		};
		Stream.prototype.parseStringBMP = function(start, end) {
			var str = "";
			for (var i = start; i < end; i += 2) {
				var high_byte = this.get(i);
				var low_byte = this.get(i + 1);
				str += String.fromCharCode((high_byte << 8) + low_byte);
			}
			return str;
		};
		Stream.prototype.reTime = /^((?:1[89]|2\d)?\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
		Stream.prototype.parseTime = function(start, end) {
			var s = this.parseStringISO(start, end),
				m = this.reTime.exec(s);
			if (!m) return "Unrecognized time: " + s;
			s = m[1] + "-" + m[2] + "-" + m[3] + " " + m[4];
			if (m[5]) {
				s += ":" + m[5];
				if (m[6]) {
					s += ":" + m[6];
					if (m[7]) s += "." + m[7];
				}
			}
			if (m[8]) {
				s += " UTC";
				if (m[8] != 'Z') {
					s += m[8];
					if (m[9]) s += ":" + m[9];
				}
			}
			return s;
		};
		Stream.prototype.parseInteger = function(start, end) {
			var len = end - start;
			if (len > 4) {
				len <<= 3;
				var s = this.get(start);
				if (s === 0) len -= 8;
				else while (s < 128) {
					s <<= 1;
					--len;
				}
				return "(" + len + " bit)";
			}
			var n = 0;
			for (var i = start; i < end; ++i) n = (n << 8) | this.get(i);
			return n;
		};
		Stream.prototype.parseBitString = function(start, end) {
			var unusedBit = this.get(start),
				lenBit = ((end - start - 1) << 3) - unusedBit,
				s = "(" + lenBit + " bit)";
			if (lenBit <= 20) {
				var skip = unusedBit;
				s += " ";
				for (var i = end - 1; i > start; --i) {
					var b = this.get(i);
					for (var j = skip; j < 8; ++j) s += (b >> j) & 1 ? "1" : "0";
					skip = 0;
				}
			}
			return s;
		};
		Stream.prototype.parseOctetString = function(start, end) {
			var len = end - start,
				s = "(" + len + " byte) ";
			if (len > hardLimit) end = start + hardLimit;
			for (var i = start; i < end; ++i) s += this.hexByte(this.get(i));
			if (len > hardLimit) s += ellipsis;
			return s;
		};
		Stream.prototype.parseOID = function(start, end) {
			var s = '',
				n = 0,
				bits = 0;
			for (var i = start; i < end; ++i) {
				var v = this.get(i);
				n = (n << 7) | (v & 0x7F);
				bits += 7;
				if (!(v & 0x80)) {
					if (s === '') {
						var m = n < 80 ? n < 40 ? 0 : 1 : 2;
						s = m + "." + (n - m * 40);
					} else s += "." + ((bits >= 31) ? "bigint" : n);
					n = bits = 0;
				}
			}
			return s;
		};

		function ASN1(stream, header, length, tag, sub) {
			this.stream = stream;
			this.header = header;
			this.length = length;
			this.tag = tag;
			this.sub = sub;
		};
		ASN1.prototype.typeName = function() {
			if (this.tag === undefined) return "unknown";
			var tagClass = this.tag >> 6,
				tagConstructed = (this.tag >> 5) & 1,
				tagNumber = this.tag & 0x1F;
			switch (tagClass) {
			case 0:
				switch (tagNumber) {
				case 0x00:
					return "EOC";
				case 0x01:
					return "BOOLEAN";
				case 0x02:
					return "INTEGER";
				case 0x03:
					return "BIT_STRING";
				case 0x04:
					return "OCTET_STRING";
				case 0x05:
					return "NULL";
				case 0x06:
					return "OBJECT_IDENTIFIER";
				case 0x07:
					return "ObjectDescriptor";
				case 0x08:
					return "EXTERNAL";
				case 0x09:
					return "REAL";
				case 0x0A:
					return "ENUMERATED";
				case 0x0B:
					return "EMBEDDED_PDV";
				case 0x0C:
					return "UTF8String";
				case 0x10:
					return "SEQUENCE";
				case 0x11:
					return "SET";
				case 0x12:
					return "NumericString";
				case 0x13:
					return "PrintableString";
				case 0x14:
					return "TeletexString";
				case 0x15:
					return "VideotexString";
				case 0x16:
					return "IA5String";
				case 0x17:
					return "UTCTime";
				case 0x18:
					return "GeneralizedTime";
				case 0x19:
					return "GraphicString";
				case 0x1A:
					return "VisibleString";
				case 0x1B:
					return "GeneralString";
				case 0x1C:
					return "UniversalString";
				case 0x1E:
					return "BMPString";
				default:
					return "Universal_" + tagNumber.toString(16);
				}
			case 1:
				return "Application_" + tagNumber.toString(16);
			case 2:
				return "[" + tagNumber + "]";
			case 3:
				return "Private_" + tagNumber.toString(16);
			}
		};
		ASN1.prototype.reSeemsASCII = /^[ -~]+$/;
		ASN1.prototype.content = function() {
			if (this.tag === undefined) return null;
			var tagClass = this.tag >> 6,
				tagNumber = this.tag & 0x1F,
				content = this.posContent(),
				len = Math.abs(this.length);
			if (tagClass !== 0) {
				if (this.sub !== null) return "(" + this.sub.length + " elem)";
				var s = this.stream.parseStringISO(content, content + Math.min(len, hardLimit));
				if (this.reSeemsASCII.test(s)) return s.substring(0, 2 * hardLimit) + ((s.length > 2 * hardLimit) ? ellipsis : "");
				else return this.stream.parseOctetString(content, content + len);
			}
			switch (tagNumber) {
			case 0x01:
				return (this.stream.get(content) === 0) ? "false" : "true";
			case 0x02:
				return this.stream.parseInteger(content, content + len);
			case 0x03:
				return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseBitString(content, content + len);
			case 0x04:
				return this.sub ? "(" + this.sub.length + " elem)" : this.stream.parseOctetString(content, content + len);
			case 0x06:
				return this.stream.parseOID(content, content + len);
			case 0x10:
			case 0x11:
				return "(" + this.sub.length + " elem)";
			case 0x0C:
				return this.stream.parseStringUTF(content, content + len);
			case 0x12:
			case 0x13:
			case 0x14:
			case 0x15:
			case 0x16:
			case 0x1A:
				return this.stream.parseStringISO(content, content + len);
			case 0x1E:
				return this.stream.parseStringBMP(content, content + len);
			case 0x17:
			case 0x18:
				return this.stream.parseTime(content, content + len);
			}
			return null;
		};
		ASN1.prototype.toString = function() {
			return this.typeName() + "@" + this.stream.pos + "[header:" + this.header + ",length:" + this.length + ",sub:" + ((this.sub === null) ? 'null' : this.sub.length) + "]";
		};
		ASN1.prototype.print = function(indent) {
			if (indent === undefined) indent = '';
			document.writeln(indent + this);
			if (this.sub !== null) {
				indent += '  ';
				for (var i = 0, max = this.sub.length; i < max; ++i) this.sub[i].print(indent);
			}
		};
		ASN1.prototype.toPrettyString = function(indent) {
			if (indent === undefined) indent = '';
			var s = indent + this.typeName() + " @" + this.stream.pos;
			if (this.length >= 0) s += "+";
			s += this.length;
			if (this.tag & 0x20) s += " (constructed)";
			else if (((this.tag == 0x03) || (this.tag == 0x04)) && (this.sub !== null)) s += " (encapsulates)";
			s += "\n";
			if (this.sub !== null) {
				indent += '  ';
				for (var i = 0, max = this.sub.length; i < max; ++i) s += this.sub[i].toPrettyString(indent);
			}
			return s;
		};
		ASN1.prototype.toDOM = function() {
			var node = DOM.tag("div", "node");
			node.asn1 = this;
			var head = DOM.tag("div", "head");
			var s = this.typeName().replace(/_/g, " ");
			head.innerHTML = s;
			var content = this.content();
			if (content !== null) {
				content = String(content).replace(/</g, "&lt;");
				var preview = DOM.tag("span", "preview");
				preview.appendChild(DOM.text(content));
				head.appendChild(preview);
			}
			node.appendChild(head);
			this.node = node;
			this.head = head;
			var value = DOM.tag("div", "value");
			s = "Offset: " + this.stream.pos + "<br/>";
			s += "Length: " + this.header + "+";
			if (this.length >= 0) s += this.length;
			else s += (-this.length) + " (undefined)";
			if (this.tag & 0x20) s += "<br/>(constructed)";
			else if (((this.tag == 0x03) || (this.tag == 0x04)) && (this.sub !== null)) s += "<br/>(encapsulates)";
			if (content !== null) {
				s += "<br/>Value:<br/><b>" + content + "</b>";
				if ((typeof oids === 'object') && (this.tag == 0x06)) {
					var oid = oids[content];
					if (oid) {
						if (oid.d) s += "<br/>" + oid.d;
						if (oid.c) s += "<br/>" + oid.c;
						if (oid.w) s += "<br/>(warning!)";
					}
				}
			}
			value.innerHTML = s;
			node.appendChild(value);
			var sub = DOM.tag("div", "sub");
			if (this.sub !== null) {
				for (var i = 0, max = this.sub.length; i < max; ++i) sub.appendChild(this.sub[i].toDOM());
			}
			node.appendChild(sub);
			head.onclick = function() {
				node.className = (node.className == "node collapsed") ? "node" : "node collapsed";
			};
			return node;
		};
		ASN1.prototype.posStart = function() {
			return this.stream.pos;
		};
		ASN1.prototype.posContent = function() {
			return this.stream.pos + this.header;
		};
		ASN1.prototype.posEnd = function() {
			return this.stream.pos + this.header + Math.abs(this.length);
		};
		ASN1.prototype.fakeHover = function(current) {
			this.node.className += " hover";
			if (current) this.head.className += " hover";
		};
		ASN1.prototype.fakeOut = function(current) {
			var re = / ?hover/;
			this.node.className = this.node.className.replace(re, "");
			if (current) this.head.className = this.head.className.replace(re, "");
		};
		ASN1.prototype.toHexDOM_sub = function(node, className, stream, start, end) {
			if (start >= end) return;
			var sub = DOM.tag("span", className);
			sub.appendChild(DOM.text(stream.hexDump(start, end)));
			node.appendChild(sub);
		};
		ASN1.prototype.toHexDOM = function(root) {
			var node = DOM.tag("span", "hex");
			if (root === undefined) root = node;
			this.head.hexNode = node;
			this.head.onmouseover = function() {
				this.hexNode.className = "hexCurrent";
			};
			this.head.onmouseout = function() {
				this.hexNode.className = "hex";
			};
			node.asn1 = this;
			node.onmouseover = function() {
				var current = !root.selected;
				if (current) {
					root.selected = this.asn1;
					this.className = "hexCurrent";
				}
				this.asn1.fakeHover(current);
			};
			node.onmouseout = function() {
				var current = (root.selected == this.asn1);
				this.asn1.fakeOut(current);
				if (current) {
					root.selected = null;
					this.className = "hex";
				}
			};
			this.toHexDOM_sub(node, "tag", this.stream, this.posStart(), this.posStart() + 1);
			this.toHexDOM_sub(node, (this.length >= 0) ? "dlen" : "ulen", this.stream, this.posStart() + 1, this.posContent());
			if (this.sub === null) node.appendChild(DOM.text(this.stream.hexDump(this.posContent(), this.posEnd())));
			else if (this.sub.length > 0) {
				var first = this.sub[0];
				var last = this.sub[this.sub.length - 1];
				this.toHexDOM_sub(node, "intro", this.stream, this.posContent(), first.posStart());
				for (var i = 0, max = this.sub.length; i < max; ++i) node.appendChild(this.sub[i].toHexDOM(root));
				this.toHexDOM_sub(node, "outro", this.stream, last.posEnd(), this.posEnd());
			}
			return node;
		};
		ASN1.prototype.toHexString = function(root) {
			return this.stream.hexDump(this.posStart(), this.posEnd(), true);
		};
		ASN1.decodeLength = function(stream) {
			var buf = stream.get(),
				len = buf & 0x7F;
			if (len == buf) return len;
			if (len > 3) throw "Length over 24 bits not supported at position " + (stream.pos - 1);
			if (len === 0) return -1;
			buf = 0;
			for (var i = 0; i < len; ++i) buf = (buf << 8) | stream.get();
			return buf;
		};
		ASN1.hasContent = function(tag, len, stream) {
			if (tag & 0x20) return true;
			if ((tag < 0x03) || (tag > 0x04)) return false;
			var p = new Stream(stream);
			if (tag == 0x03) p.get();
			var subTag = p.get();
			if ((subTag >> 6) & 0x01) return false;
			try {
				var subLength = ASN1.decodeLength(p);
				return ((p.pos - stream.pos) + subLength == len);
			} catch (exception) {
				return false;
			}
		};
		ASN1.decode = function(stream) {
			if (!(stream instanceof Stream)) stream = new Stream(stream, 0);
			var streamStart = new Stream(stream),
				tag = stream.get(),
				len = ASN1.decodeLength(stream),
				header = stream.pos - streamStart.pos,
				sub = null;
			if (ASN1.hasContent(tag, len, stream)) {
				var start = stream.pos;
				if (tag == 0x03) stream.get();
				sub = [];
				if (len >= 0) {
					var end = start + len;
					while (stream.pos < end) sub[sub.length] = ASN1.decode(stream);
					if (stream.pos != end) throw "Content size is not correct for container starting at offset " + start;
				} else {
					try {
						for (;;) {
							var s = ASN1.decode(stream);
							if (s.tag === 0) break;
							sub[sub.length] = s;
						}
						len = start - stream.pos;
					} catch (e) {
						throw "Exception while decoding undefined length content: " + e;
					}
				}
			} else stream.pos += len;
			return new ASN1(streamStart, header, len, tag, sub);
		};
		ASN1.test = function() {
			var test = [{
				value: [0x27],
				expected: 0x27
			}, {
				value: [0x81, 0xC9],
				expected: 0xC9
			}, {
				value: [0x83, 0xFE, 0xDC, 0xBA],
				expected: 0xFEDCBA
			}];
			for (var i = 0, max = test.length; i < max; ++i) {
				var pos = 0,
					stream = new Stream(test[i].value, 0),
					res = ASN1.decodeLength(stream);
				if (res != test[i].expected) document.write("In test[" + i + "] expected " + test[i].expected + " got " + res + "\n");
			}
		};
		window.ASN1 = ASN1;
	})();
	ASN1.prototype.getHexStringValue = function() {
		var hexString = this.toHexString();
		var offset = this.header * 2;
		var length = this.length * 2;
		return hexString.substr(offset, length);
	};
	RSAKey.prototype.parseKey = function(pem) {
		try {
			var modulus = 0;
			var public_exponent = 0;
			var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
			var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
			var asn1 = ASN1.decode(der);
			if (asn1.sub.length === 3) {
				asn1 = asn1.sub[2].sub[0];
			}
			if (asn1.sub.length === 9) {
				modulus = asn1.sub[1].getHexStringValue();
				this.n = parseBigInt(modulus, 16);
				public_exponent = asn1.sub[2].getHexStringValue();
				this.e = parseInt(public_exponent, 16);
				var private_exponent = asn1.sub[3].getHexStringValue();
				this.d = parseBigInt(private_exponent, 16);
				var prime1 = asn1.sub[4].getHexStringValue();
				this.p = parseBigInt(prime1, 16);
				var prime2 = asn1.sub[5].getHexStringValue();
				this.q = parseBigInt(prime2, 16);
				var exponent1 = asn1.sub[6].getHexStringValue();
				this.dmp1 = parseBigInt(exponent1, 16);
				var exponent2 = asn1.sub[7].getHexStringValue();
				this.dmq1 = parseBigInt(exponent2, 16);
				var coefficient = asn1.sub[8].getHexStringValue();
				this.coeff = parseBigInt(coefficient, 16);
			} else if (asn1.sub.length === 2) {
				var start = (asn1.header + asn1.sub[0].header) * 2;
				var length = asn1.sub[0].length * 2;
				modulus = pem.substr(start, length);
				this.n = parseBigInt(modulus, 16);
				start = length + start + asn1.sub[1].header * 2;
				length = asn1.sub[1].length * 2;
				public_exponent = pem.substr(start, length);
				this.e = parseInt(public_exponent, 16);
			} else {
				return false;
			}
			return true;
		} catch (ex) {
			return false;
		}
	};
	RSAKey.prototype.getPrivateBaseKey = function() {
		var options = {
			'array': [new KJUR.asn1.DERInteger({
				'int': 0
			}), new KJUR.asn1.DERInteger({
				'bigint': this.n
			}), new KJUR.asn1.DERInteger({
				'int': this.e
			}), new KJUR.asn1.DERInteger({
				'bigint': this.d
			}), new KJUR.asn1.DERInteger({
				'bigint': this.p
			}), new KJUR.asn1.DERInteger({
				'bigint': this.q
			}), new KJUR.asn1.DERInteger({
				'bigint': this.dmp1
			}), new KJUR.asn1.DERInteger({
				'bigint': this.dmq1
			}), new KJUR.asn1.DERInteger({
				'bigint': this.coeff
			})]
		};
		var seq = new KJUR.asn1.DERSequence(options);
		return seq.getEncodedHex();
	};
	RSAKey.prototype.getPrivateBaseKeyB64 = function() {
		return hex2b64(this.getPrivateBaseKey());
	};
	RSAKey.prototype.getPublicBaseKey = function() {
		var options = {
			'array': [new KJUR.asn1.DERObjectIdentifier({
				'oid': '1.2.840.113549.1.1.1'
			}), new KJUR.asn1.DERNull()]
		};
		var first_sequence = new KJUR.asn1.DERSequence(options);
		options = {
			'array': [new KJUR.asn1.DERInteger({
				'bigint': this.n
			}), new KJUR.asn1.DERInteger({
				'int': this.e
			})]
		};
		var second_sequence = new KJUR.asn1.DERSequence(options);
		options = {
			'hex': '00' + second_sequence.getEncodedHex()
		};
		var bit_string = new KJUR.asn1.DERBitString(options);
		options = {
			'array': [first_sequence, bit_string]
		};
		var seq = new KJUR.asn1.DERSequence(options);
		return seq.getEncodedHex();
	};
	RSAKey.prototype.getPublicBaseKeyB64 = function() {
		return hex2b64(this.getPublicBaseKey());
	};
	RSAKey.prototype.wordwrap = function(str, width) {
		width = width || 64;
		if (!str) {
			return str;
		}
		var regex = '(.{1,' + width + '})( +|$\n?)|(.{1,' + width + '})';
		return str.match(RegExp(regex, 'g')).join('\n');
	};
	RSAKey.prototype.getPrivateKey = function() {
		var key = "-----BEGIN RSA PRIVATE KEY-----\n";
		key += this.wordwrap(this.getPrivateBaseKeyB64()) + "\n";
		key += "-----END RSA PRIVATE KEY-----";
		return key;
	};
	RSAKey.prototype.getPublicKey = function() {
		var key = "-----BEGIN PUBLIC KEY-----\n";
		key += this.wordwrap(this.getPublicBaseKeyB64()) + "\n";
		key += "-----END PUBLIC KEY-----";
		return key;
	};
	RSAKey.prototype.hasPublicKeyProperty = function(obj) {
		obj = obj || {};
		return (obj.hasOwnProperty('n') && obj.hasOwnProperty('e'));
	};
	RSAKey.prototype.hasPrivateKeyProperty = function(obj) {
		obj = obj || {};
		return (obj.hasOwnProperty('n') && obj.hasOwnProperty('e') && obj.hasOwnProperty('d') && obj.hasOwnProperty('p') && obj.hasOwnProperty('q') && obj.hasOwnProperty('dmp1') && obj.hasOwnProperty('dmq1') && obj.hasOwnProperty('coeff'));
	};
	RSAKey.prototype.parsePropertiesFrom = function(obj) {
		this.n = obj.n;
		this.e = obj.e;
		if (obj.hasOwnProperty('d')) {
			this.d = obj.d;
			this.p = obj.p;
			this.q = obj.q;
			this.dmp1 = obj.dmp1;
			this.dmq1 = obj.dmq1;
			this.coeff = obj.coeff;
		}
	};
	var JSEncryptRSAKey = function(key) {
			RSAKey.call(this);
			if (key) {
				if (typeof key === 'string') {
					this.parseKey(key);
				} else if (this.hasPrivateKeyProperty(key) || this.hasPublicKeyProperty(key)) {
					this.parsePropertiesFrom(key);
				}
			}
		};
	JSEncryptRSAKey.prototype = new RSAKey();
	JSEncryptRSAKey.prototype.constructor = JSEncryptRSAKey;
	var JSEncrypt = function(options) {
			options = options || {};
			this.default_key_size = parseInt(options.default_key_size) || 1024;
			this.default_public_exponent = options.default_public_exponent || '010001';
			this.log = options.log || false;
			this.key = null;
		};
	JSEncrypt.prototype.setKey = function(key) {
		if (this.log && this.key) {
			console.warn('A key was already set, overriding existing.');
		}
		this.key = new JSEncryptRSAKey(key);
	};
	JSEncrypt.prototype.setPrivateKey = function(privkey) {
		this.setKey(privkey);
	};
	JSEncrypt.prototype.setPublicKey = function(pubkey) {
		this.setKey(pubkey);
	};
	JSEncrypt.prototype.decrypt = function(string) {
		try {
			return this.getKey().decrypt(b64tohex(string));
		} catch (ex) {
			return false;
		}
	};
	JSEncrypt.prototype.encrypt = function(string) {
		try {
			return (this.getKey().encrypt(string));
		} catch (ex) {
			return false;
		}
	};
	JSEncrypt.prototype.getKey = function(cb) {
		if (!this.key) {
			this.key = new JSEncryptRSAKey();
			if (cb && {}.toString.call(cb) === '[object Function]') {
				this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
				return;
			}
			this.key.generate(this.default_key_size, this.default_public_exponent);
		}
		return this.key;
	};
	JSEncrypt.prototype.getPrivateKey = function() {
		return this.getKey().getPrivateKey();
	};
	JSEncrypt.prototype.getPrivateKeyB64 = function() {
		return this.getKey().getPrivateBaseKeyB64();
	};
	JSEncrypt.prototype.getPublicKey = function() {
		return this.getKey().getPublicKey();
	};
	JSEncrypt.prototype.getPublicKeyB64 = function() {
		return this.getKey().getPublicBaseKeyB64();
	};
	exports.JSEncrypt = JSEncrypt;
})(JSEncryptExports);
var JSEncrypt = JSEncryptExports.JSEncrypt;